

















# 1. 有限状态自动机-下推自动机-图灵机：理论




命题逻辑为什么图灵不完整？
https://math.stackexchange.com/questions/348379/why-is-propositional-logic-not-turing-complete


-------------------------------------------------------------------------

**图灵完备**是完整性的最一般形式定义。有些语言功能对于某些应用程序是必需的，但是这些语言功能不适合正式的定义。

例如，图形功能，产生后台进程的能力，保持状态的能力以及连接到网络的能力都是有用的功能，但与语言的图灵完备性无关。因此，Google App Engine上的Python或在沙箱中运行的Java applet仍然是图灵完整的。

您会注意到，在许多情况下，这些类型的功能是由库而不是核心语言提供的。

语言可以做或不能做类似的事情-子例程，递归，自定义数据类型，循环，定义类，goto等。此类语言功能集使它变得完整或不完整。例如，如果您没有循环，gotos和子例程，则语言是不完整的-您无法执行任何循环操作。语言完整性是非常理论和科学的事情。例如，即使您的语言不允许递归调用函数，但允许函数指针，也证明了这一点-您可以模拟递归，即使用y-combinator。根据上下文，“用某种语言完成某件事”对不同的人意味着不同的事情。图灵就是其中之一，他非常精确地定义了“完整”的含义。

如果一门语言（或理论机器）完成了图灵运算，则没有图灵计算无法做到的。这并不意味着该语言是万能的，而是精通总结。有许多不是图灵计算的“事物”，因此，图灵完备的计算机可能无法执行。

“成为操作系统”不是图灵计算。要成为一个操作系统，您需要做的不仅仅是计算。您还需要操纵硬件。

有了图灵完整的语言，再加上一组用于执行所需的所有硬件操作的操作，包括适当的输入和时间概念，您就可以编写OS。或者我应该说，可以编写一个OS。您个人是否可以执行此操作取决于该语言的易用性以及Turing定义所忽略的物理限制，例如生成的程序是否真正适合并在您希望其操作的设备的内存中执行，并在现实的时间内运行。

尽管忽略了实际限制-是的，您可以使用任何Turing完整语言编写OS，前提是该语言也具有足够的操作来驱动硬件。如果您希望采用实用的CS方法来区分语言和库，请使用“库调用”。Turing没有这种区别，因为他的计算模型始终没有“呼叫”的概念。您还需要解决引导程序问题-您的硬件必须直接运行您正在编写的语言，或者您需要将编译器编译为硬件可以运行的语言，或者您需要以该语言编写的解释器硬件运行。再次，Turing忽略了所有这一切，因为他的计算模型使用了抽象硬件，而编写OS完全是关于硬件的。https://stackoverflow.com/questions/813657/can-a-language-be-turing-complete-but-incomplete-in-other-ways


https://en.m.wikipedia.org/wiki/Stack-oriented_programming仅基于单个堆栈的语言是不完整的图灵（除非您通过允许使用诸如临时变量之类的东西来“欺骗”或在堆栈中访问比顶部项目“更深”的值）。据我了解，这种语言等效于下推自动机（Pushdown Automata），它可以实现某些功能（例如，上下文无关的语法），但肯定不及完整的图灵机那么多。

话虽这么说，图灵机实际上比您直观地期望的要低得多-按照最初的公式，它们只不过是链表，读取和修改链表以及分支的功能而已。您甚至不需要在纯面向堆栈的语言中添加太多内容，使其等效于Turing机器-从技术上讲，第二个堆栈可以做到这一点（尽管我当然不想针对它进行编程）链表或队列。

如果我错了，请指正我，但我认为确定**可以读取和写入内存，可以进行分支，并至少具有这些数据结构中的一种（两个堆栈，一个队列，一个链接列表或等价物）足以确定图灵完整性**。

也请看一下嵌套堆栈自动机。

您可能还需要查看Chomsky层次结构（似乎您可能漂浮在Type 1或Type 2语言附近的某个地方）。
https://stackoverflow.com/questions/44866577/proof-of-turing-completeness-for-a-stack-based-language

https://cs.stackexchange.com/questions/19676/how-close-are-common-programming-languages-to-not-being-turing-complete



想到后一搜，果然已经有人提过这样有趣的问题：“既然有些编译器是根据下推自动机的原理制造的，比如yacc是lalr(1)，只能识别上下文无关文法，那么这个语言本身为什么可以是图灵完备的呢，或者说为什么下推自动机可以模拟图灵机去编译或解释运行图灵完备的语言呢？”

为什么下推自动机可以用来编译或解释图灵完备的语言呢？ - 知乎
https://www.zhihu.com/question/49556813/answer/116640645 因为**编译出来的程序是由图灵完备的计算机执行的**，编译器不是程序的执行者，parser 更不是程序的执行者。

明明dpa等价识别上下文无关文法，能力不足的程序设计语言能操纵图灵机等效RAM寄存器虚拟机 ，实现图灵完备？

为什么下推自动机可以用来编译或解释图灵完备的语言呢？ - Tridu的回答 - 知乎
https://www.zhihu.com/question/49556813/answer/1849722566

**理论分析是严苛的，实际操作却是灵活的，而且上下文无关文法已经很强大以至于我们产生错觉混淆**，要记住一些turing机能做 dpa不能做的文法语言问题“已经知道我们无法使用FSM或下推自动机来解释图灵完整的语言。那么一些限制性更强的语言又会如何生成任意长度的重复二进制模式呢？”就行。

《计算的本质:》

---------------------------------------------------------------------------------------------------------


https://cs.stackexchange.com/questions/98295/can-pda-model-turing-complete-objects-if-the-objects-state-are-finite
**对象变量的域限制为有限集。因此，可以使用下推自动机（PDA）对此类对象进行建模。**



是否可以编写自我解释的FSM或下推式自动机？
https://stackoverflow.com/questions/5205469/is-it-possible-to-write-a-self-interpreting-fsm-or-pushdown-automaton
编程语言的自举是用CFG描述自己的CFG。自仿真一个特定上下文无关文法规则下的自编码。

pda做不到图灵完备?《计算的本质》一书指出“重复字符不可匹配”

https://math.stackexchange.com/questions/3103807/how-to-prove-or-disprove-that-a-machine-is-turing-complete
如何证明或证明机器是图灵完成的？





已经知道我们无法使用FSM或下推自动机来解释图灵完整的语言。那么一些限制性更强的语言又会如何生成任意长度的重复二进制模式呢？

基于堆栈的VM如何实现图灵完成？
https://en.m.wikipedia.org/wiki/Stack-oriented_programming
您正在将下推式自动机与**面向堆栈的编程语言**（或它们的解释模型）相混淆。前者可以是图灵完备的，因为它们可以访问（无限）随机存取存储器；因此，它们可以是图灵完备的。后者没有内存，但是（一个）堆栈。


如果只允许堆栈机访问堆栈的顶部，并且除了堆栈之外，它仅具有有限的存储量，则它是下推式自动机。下推式自动机不是图灵完整的；非确定性下推自动机只能识别上下文无关的语言，而确定性语言则更少。

由于具有两个堆栈，因此该机器可以从任一堆栈中推入和弹出，因此该机器等效于图灵机。这很容易看到：给定一个图灵机，您可以通过将输入推入一个堆栈，然后将磁带上的向前运动视为从第一个堆栈弹出并推入第二个堆栈来构建等效的两堆栈自动机，反之亦然。

如果允许堆栈计算机从堆栈中的任何位置访问数据（通常是在使用堆栈计算机构建虚拟机时就是这种情况），那么情况就不一样了。在这种情况下，堆栈的形状无关紧要，您所拥有的是一台随机存取机。从可计算性的角度来看，它与寄存器机相同，只是寄存器的命名方式有关：通过将其称为“堆栈机”，您只是说寄存器是以某种方式编号的。 。

**RAM等效于图灵机**。RAM有一个细微之处：寄存器不是有限寄存器，它们是“可变大小”寄存器，可以容纳计算所需的数字。实际上，大多数具体的机器都是这样的-寄存器或存储单元的大小足以存储指针，并且如果指针的大小超过寄存器的大小，则意味着您的机器内存已溢出然后在具有更多内存和更大寄存器的计算机上再次开始计算。



https://stackoverflow.com/questions/7487045/is-the-java-virtual-machine-language-agnostic
从某种意义上说，JVM和Java字节码是图灵完整的(？我对回答中这个说法存疑?)，可以将任何其他图灵完整的语言转换并编译为Java字节码，然后在JVM上运行。它可能效率极低，但并非没有可能。至于“不可知论者”的最严格定义，就没有这样的东西。在硬件级别，所有处理器都有一组支持的已定义二进制指令，因此在任何时候，任何语言都必须转换为与其应在其上执行的硬件兼容的程序集。

编辑：JVM并不是在真空中开发的，它是与JAVA编程语言一起开发的，因此可以说Java语言在很大程度上影响了Java字节码和JVM的设计。因此，从这个意义上讲，您可以说JVM是在考虑Java的情况下设计的。但是，也确实是在架构中，JVM是有意识地与Java语言分离的（通过中间字节码格式），因此设计中的某些元素考虑了可能的替代语言。

JVM字节码伪装成一种通用机器码，的确如此，所以……是什么让您认为它不支持任何其他语言？JVM字节码是一种图灵完整的语言，因此，无论使用哪种语言编写，每个程序都可以编译/翻译成字节码。

有许多语言已经具有字节码编译器（例如，用于Python的Jython和用于Ruby的JRuby），并且与Java也有很大的不同。

请注意，从技术上讲，每种图灵完整的编程语言都可以编译成另一种。例如，可以将JS编译为C或将Ruby编译为Python。






如果Scala在JVM上运行，Scala怎么做Java看似不能做的事情？[复制]
https://softwareengineering.stackexchange.com/questions/280169/if-scala-runs-on-the-jvm-how-can-scala-do-things-that-java-seemingly-cannot


https://cs.stackexchange.com/questions/44305/why-are-functional-languages-turing-complete
函数式编程是图灵完备的  简单通过lambda演算的图灵完备就能证明出来









-----------------------------------------------------------------


可能是个话题，但想问很久这个问题：
为什么我们没有通用的神经网络能够模拟任何输入上的任何网络？那有可能吗？

RNN图灵完备了吗？
https://www.reddit.com/r/MachineLearning/comments/6il5rk/d_rnns_are_not_really_turing_complete_in_any/



https://studylib.net/doc/25203772/-machine-learning-for-decision-makers-cognitive-computing...
机器学习决策马尔可夫过程









-----------------------------------------------


群友ntelstealer：我想了想 我似乎本质上是在问  是否  对任意一个停机的程序p，都存在一个有穷自动机A，使得A接受所有可能的程序行为w ( 集合behavior(p) = L(A) ) 而答案应该是yes，因为实际程序的状态集合是有限的，而且在每一个可能的状态s1应该进入的下一个状态s2都是由p确定的，所以可以这样说吗？我问一开始的问题的原因是因为我在想control flow graph和finite autumata能产生什么联系。如果说我考虑c语言一个函数f(...) 那它的输入总是有限的。这个函数被调用的时候，一开始的状态实际上就是内存中的值和参数的值，而在实际机器中这些都是有限的，所以一开始的状态首先是有限的；下一个状态应该是什么是由函数f的内容，即CFG确定的。所以从这个角度看，f 确实对应了一个DFA


认为你这样说是对的。自动机本身就能写成“if then rules表格形式/状态表示法后节点迁移图的形式”。



即使限定f是total的，即对所有输入停机，那么也只能说对每个输入来说f的trace对应一个DFA，对不同的输入对应的DFA可以是不同的呢

@正规子群 这里输入不同相同感觉上有点模糊。应该是说给定有限状态自动机，能识别对应正则文法的输入吧。


如果说有限自动机生成函数trace写出来的线性程序，这应该是1:n的关系。
只要把一个**控制流图CFG(有限状态机/状态转换图/迁移系统/决策过程动作序列行为树/计算图)**{同一张图不同领域不同叫法，程序设计AST-CFG/自动机/pert事件驱动领域建模计时事件AOV网络/ModelChecking/Markov随机过程看作DFA等价转换为NFA就像QNP2FOND的关联/计算图是TVM机器学习框架中的概念，类比程序设计语言的AST}序列化，拓扑排序能得到初态到终态对应 函数程序的代码binary ast有很多种写法。

>"**根本没有输出函数的有限状态机叫做半自动机或转移系统**"，那么按照有限状态自动机的定义没有输出函数难道就是半自动机吗。

根本没有输出有限状态机叫做转移系统，没有输出的自动机叫做转移系统！


请问基于单栈的栈虚拟机上只能是下推自动机，只能识别上下文无关文法输入吗？不是图灵完备吗？wasm,cpython,java等等


The Fillet：所谓的stack based vm一般都带个可以随机访问的存储空间，如果没有，表达力只有pda



-----------------------------------------------------------------------------



抽象解释 如何理解抽象解释（abstract interpretation）？ - 陈炜的回答 - 知乎
https://www.zhihu.com/question/27789493/answer/38107549



























































# 2. 应用落地

https://github.com/liangyihuai/JavaLearning
java有限状态机
https://blog.csdn.net/liangyihuai/article/details/82261978 java下推自动机









以太坊平台使用图灵完备的语言构建而成，该语言在功能上与比特币不同。
https://hackernoon.com/ethereum-turing-completeness-and-rich-statefulness-explained-e650db7fc1fb

纸质智能合约应用在线检测有效免费对象的扩展版本。

我试图理解第6章的证明。特别是，我无法理解6.2的前提。实际上，作者使用了SMAC的变体，即面向对象的图灵完成（SMAC），他们声称（我用粗体强调了可疑的说法）

因此，我们专注于验证 小号ËCF，即静态验证对象的所有执行是否 dËCFF小号 或者 ËCFC，其中对象变量的域限制为有限集。因此，可以使用下推自动机（PDA）对此类对象进行建模。此类用于对象的PDA能够模拟任何模块化的格式正确的执行κ ＆Element; π 所有状态的活动对象位于 π是o。

在我的理解中，这个前提应该是错误的，因为尽管此SMAC程序的状态是最终状态，但不能通过Push-Down-Automata（用于计算总功能）进行计算。

























































