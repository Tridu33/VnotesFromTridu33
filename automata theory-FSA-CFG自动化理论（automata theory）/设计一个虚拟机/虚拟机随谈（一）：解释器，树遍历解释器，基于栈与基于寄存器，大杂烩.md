# 1. 虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩



R大
https://blog.csdn.net/zhangxinrun/article/details/6562647
原始地址的图片挂掉了吗 https://www.iteye.com/blog/rednaxelafx-492667





基于栈的解析器与基于寄存器的解析器



javascriptcore是基于寄存器的，V8是基于栈的





近来“scannerless parsing ”也挺流行的：不区分词法分析与语法分析，没有单独的扫描器，直接用解析器从源码生成语法树。这倒整个就是解析器了，没狭不狭义的问题）



Ch是C / C ++解释器和脚本语言环境。它被全世界的教师，学生，工程师和科学家用来学习数学，计算，C / C ++，并快速有效地编写跨平台代码和嵌入式脚本。Ch是现有的最完整的跨平台C解释器和C脚本引擎。它是C / C ++编译器用于教学的一种更简单的替代解决方案，特别是对于 Barobo的 Raspberry Pi，Arduino和Linkbot。 http://www.softintegration.com/




C一般被认为是“编译型语言”，但C的解释器也是存在的，例如Ch 。同样，C++也有解释器版本的实现，例如Cint 。
一般被称为“解释型语言”的是主流实现为解释器的语言，但并不是说它就无法编译。例如说经常被认为是“解释型语言”的Scheme 就有好几种编译器实现，其中率先支持R6RS 规范的大部分内容的是Ikarus ，支持在x86上编译Scheme；它最终不是生成某种虚拟机的字节码，而是直接生成x86机器码。

解释器就是个黑箱，输入是源码，输出就是输入程序的执行结果，对用户来说中间没有独立的“编译”步骤。








虚拟机（virtual machine ，VM） 又是什么？在许多不同的场合，VM有着不同的意义。如果上下文是Java、Python这类语言，那么一般指的是高级语言虚拟机（high-level language virtual machine，HLL VM），其意义是实现高级语言的语义。VM既然被称为“机器”，一般认为输入是满足某种指令集架构（instruction set architecture ，ISA）的指令序列，中间转换为目标ISA的指令序列并加以执行，输出为程序的执行结果的，就是VM。源与目标ISA可以是同一种，这是所谓same-ISA VM。

前面提到解释器中的编译器的输出可能是**AST**，也可能是**字节码之类的指令序列**；一般会把执行后者的程序称为VM，而执行前者的还是笼统称为解释器 或者**树遍历式解释器（tree-walking interpreter）**。这只是种习惯而已，并没有多少确凿的依据。只不过线性（相对于树形）的指令序列看起来更像一般真正机器会执行的指令序列而已。

其实我觉得把执行AST的也叫VM也没啥大问题。如果认同这个观点，那么把DLR 看作一种VM也就可以接受了——它的“指令集”就是树形的Expression Tree。





换个角度说，我觉得采用编译和解释方式实现虚拟机最大的区别就在于**是否存下目标代码**：

编译的话会把输入的源程序以某种单位（例如基本块 / 函数/方法/trace等）翻译生成为目标代码，并存下来（无论是存在内存中还是磁盘上，无所谓），后续执行可以复用之；

解释的话则把源程序中的指令是逐 条解释，不生成也不存下目标代码，后续执行没有多少可复用的信息。

有些稍微先进一点的解释器可能会优化输入的源程序，把满足某些模式的指令序列合并为“超 级指令”；这么做就是朝着编译的方向推进。后面讲到解释器的演化时再讨论超级指令吧。




VM并不是神奇的就能执行代码了，它也得采用某种方式去实现输入程序的语义，并且同样有几种选择：“**编译**”，例如微软的.NET中的CLR；“**解 释**”，例如CPython、CRuby 1.9，许多老的JavaScript引擎等；也有介于两者之间的混合式，例如Sun的JVM，HotSpot 。

如果采用编译方式，VM会把输入的指令先转换为某种能被底下的系统直接执行的形式（一般就是native code），然后再执行之；

如果采用解释方式，则VM会把输入的指令逐条直接执行。






从树遍历解释器进化为基于栈的字节码解释器的前端

如果你看到树形结构与后序遍历，并且知道后缀记法（或者逆波兰记法，reverse Polish notation ）的话，那敏锐的你或许已经察觉了：要解释执行AST，可以先通过后序遍历AST生成对应的后缀记法的操作序列，然后再解释执行该操作序列。这样就把树形结构压扁，成为了线性结构。
















































































































