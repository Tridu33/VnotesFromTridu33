


B站教程操作系统视频的汇总，以后的发的也会补上。
完整信息列表详见：
Github: https://github.com/carsonDB/CS-courses#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F
Gitee: https://gitee.com/carsondb/CS-courses#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F
作者自己写的软件：http://carsondb.gitee.io/animeBoard/
https://github.com/carsonDB/animeBoard
repo只有文档，介绍页面的代码，不包含软件部分，软件是闭源的

# 1. 计算机操作系统


[操作系统教程期末复习笔记第五版万字长文预警！！！](https://zhuanlan.zhihu.com/p/53780850)


[面试CS基础——操作系统笔记](https://zhuanlan.zhihu.com/p/27568866)

 


[本科生写操作系统需要克服哪些难关？](https://zhuanlan.zhihu.com/p/27659059)

[深入理解并发/并行，阻塞/非阻塞，同步/异步](https://zhuanlan.zhihu.com/p/31780549)
[最后发个以前写的模拟CPU调度的程序](https://github.com/hehe520/Data-structure-and-algorithm/tree/master/操作系统相关算法/进程调度和页面置换算法)





面试CS基础——操作系统笔记 - 牛客网的文章 - 知乎
https://zhuanlan.zhihu.com/p/27568866



https://www.bilibili.com/video/BV1YE411D7nH?p=31 王道 论坛OS


https://blog.csdn.net/gl620321/article/details/107128661  操作系统思维导图---（零基础---思维导图详细版本及知识点）






## 1.1. 操作系统笔记这里是王道书上没有的知乎专栏《操作系统笔记》https://zhuanlan.zhihu.com/c_142990858


[OS 实验一 | linux 内核编译及添加系统调用](https://zhuanlan.zhihu.com/p/31342840)

[OS 实验二 | Linux 内核模块编程](https://zhuanlan.zhihu.com/p/31654977)

https://zhuanlan.zhihu.com/p/31630912  进程与进程管理 | 进程同步机制  a这里比王道P73说得生动
https://zhuanlan.zhihu.com/p/31638516   经典王道P81同步问题
通过共享某些数据结构或共享存储器实现进程之间的信息交换。


https://zhuanlan.zhihu.com/p/31868972  进程调度+调度算法

https://zhuanlan.zhihu.com/p/31922773  死锁

https://zhuanlan.zhihu.com/p/31861375  进程与进程管理 | 进程通信（）共享存储器系统通信+管道通信+消息传递系统通信
通信过程： linux中相应系统调用
申请共享存储分区； shmget（）
将共享存储分区映射到本进程地址空间中； shmat（）
进行数据读写；
释放共享存储分区； shmdt（）
删除共享存储分区： shmctl（）
共享存储器系统通信方式的特点：
最大的特点是没有中间环节，直接把共享内存映射到不同进程的虚拟地址空间中，进程可直接进行访问，通信直接快速。
该通信机制没有提供进程同步机制。
代码描述：







**实时任务的分类**
按任务执行时是否呈现周期性划分
周期性实时任务：工作生产线
非周期性实时任务：导弹拦截任务
根据对截止时间的要求来划分
硬实时任务：必须保证截止时间，如导弹拦截系统。
软实时任务：最好保证截止时间，但不是必须。如生产线，最大的后果就是产生次品。
实时系统与分时系统的比较
设计目标不同：实时系统是专用性的系统，而分时系统是通用性的系统，如Linux。
多路性：实时信息处理系统与分时系统类似
独立性：实时信息处理系统与分时系统类似
及时性：实时系统更高
交互性：分时系统最强，可以实现各种的工作。而实时系统的任务却是单一的，高压锅炉的操作系统，流水线的操作系统......
可靠性：实时系统要求高度可靠，如医院病房的监测报警系统。

**多处理机系统**
多处理机系统也称并行系统(parallel system)或紧耦合系统。

定义
包含两个或多个功能相当的处理器
所有处理器共享一个公共内存
所有处理器共享I/O通道、控制器和外围设备
由一个操作系统控制
实现方式
非对称多处理机模式（又称主-从模式），主处理机运行操作系统，并且控制系统中的所有资源，为其余的从处理器分配任务。从处理机只处理主处理分配的任务。但是如果主处理机出现问题，就会导致整个系统的崩溃，存在可靠性问题。
对称多处理机模式，所有的处理机都运行操作系统，每个处理机完成自己的任务。
多处理机系统的特点
具有并行处理能力，效率高
紧耦合：存在瓶颈、可扩展性差
不支持大规模并行计算；不支持分布处理：将一个大的任务分为几个小的任务进行分布执行，

**
网络操作系统**
由线路将一些独立自治的计算机相互连接形成的一个集合体称为计算机网络。每个计算机的各自操作系统都可以不同。每一台都是独立的。

###### 1.1.1.1.1.1. [操作系统的结构和硬件支持---繁琐非常](https://zhuanlan.zhihu.com/p/31498470)
-   操作系统的结构模型

--   单体结构实例：AT&T SystemV，BSD UNIX


--   模块化结构
实例：Choices系统，实验性质

--  微内核结构


将系统核心分为两部分，基础核心功能和其他核心功能。


如上，微内核结构的示意图。在这其中客户进程和操作系统的其他进程都包含在操作系统的用户态下面。当客户进程需要调用操作系统的某项服务功能的时候，比如需要访问文件进程的时候，操作系统需要将对文件进程的请求发送给微内核，微内核进过检测后再把这个请求发送给文件服务器进程。文件服务器进程再通过微内核传递给客户进程。这样就存在一个比较严重的问题，就是当客户进程比较多的时候，会造成微内核的繁忙。所以在该微内核结构中微内核可能会成为整个系统的瓶颈。因此，我们一般会仔细考虑进程的存放位置，是运行在微内核中还是在用户态中，已达到节约对微内核的请求访问的目的。

实例：
Mach系统
Tru64 UNIX系统
Win NT

--  层次结构  把 OS 的功能模块划分为若干层，每层之间的模块只能单向调用。
![](_v_images/1549789075_7139.png)
实例：Dijkstra的THE系统

- -   计算机操作系统的体系结构模型王道的书只说了大内核和微内核


## 1.2. 实例操作系统的结构

-   **UNIX**操作系统的结构：**单体式**

![](https://pic4.zhimg.com/80/v2-2a305a38b2cec384299fe2d4b197148f_hd.jpg)

-   UNIX核心层

-   处理机管理
-   存储管理
-   设备管理
-   文件系统

-   UNIX实用层

-   实用程序 —— 编辑程序、调试程序、系统状态监控、文件管理等实用程序
-   存储管理软件工具 ——源代码控制程序SCCS、文档准备程序包等








-   **Linux**系统的核心结构：**单体式**

![](https://pic1.zhimg.com/80/v2-e707bcbfd586735c43219af91aa4ee40_hd.jpg)

-   其中整个内核是由相应的过程来完成的。

  

-   **Windows**操作系统的结构：**微内核**

![](https://pic3.zhimg.com/80/v2-e8b363641b4322c67996c05782e486c2_hd.jpg)

![](https://pic3.zhimg.com/80/v2-e8b363641b4322c67996c05782e486c2_hd.jpg)

-   其中应用程序的运行，是由运行在用户态下面的虚拟机来完成的，而微内核中提供了虚拟机的管理模块。

## 1.3. 处理机的特权级

计算机系统中运行的程序大体上可以分为管理程序和用户程序两大类。


-   实例操作系统处理机的状态

-   DOS 系统

-   不分态

-   Windows 系统

-   3环 用户态
-   0环 系统态
-   还有1、2环预留

-   UNIX / Linux 系统

-   00 管态
-   11 用户态

## 1.4. 中断及其处理

-   中断的概念

-   是指CPU暂停执行当前的指令流程，去处理外部设备或硬件的中断信号的过程 。

![](https://pic3.zhimg.com/80/v2-f7f75e7c8d14477c681f97a0a53b4b66_hd.jpg)

-   中断类型

-   按中断功能分类

-   **输入输出中断：** I/O传输结束或出错中断
-   **外中断：** 时钟中断、操作员控制台中断、通信中断等
-   **机器故障中断：** 电源故障、主存取指令错等
-   **程序性中断**（CPU执行指令的过程中出现的中断）**：** 定点溢出、用户态下用核态指令、非法操作
-   **访管中断**（为了方便应用程序调用操作系统的内核功能而提供的一种中断）**：** 对操作系统提出某种需求时所发出的中断

-   按中断来源分类：

-   **中断：** 由处理机外部事件引起的中断
-   **俘获：** 由处理机内部事件引起的中断，x86中称**异常**

![](https://pic4.zhimg.com/80/v2-e4454205977e1eac520dd46c4b08d51f_hd.jpg)

-   中断屏蔽（针对可屏蔽中断而言，如所有 I/O 中断）

-   暂时地禁止中断

-   中断信号丢失

-   由特权指令设置中断屏蔽寄存器
-   在系统中，与中断有关的寄存器有如下三种：

![](https://pic2.zhimg.com/80/v2-795c73aef503cbf1de9dc887af810781_hd.jpg)

-   中断寄存器用来保存各个终端到达的信号。每当有一个终端到达，就会把中断寄存器相应的位置设为1
-   屏蔽寄存器用来实现中断屏蔽，当其中有一位为1，表示该类中断不被屏蔽，系统可以响应。为0，则屏蔽不响应。
-   CPU标志寄存器，表示CPU能否响应可屏蔽中断，如果相应标志为的值为1，则表示对于所有的可屏蔽中断CPU都可以响应。如果为0，则不管屏蔽寄存器的值为多少，CPU都不响应。
-   所以只有当屏蔽寄存器和CPU标志寄存器相应的位置上的值都为1的时候，CPU才会响应中断。

  

-   中断优先级

-   规定对同时达到中断的处理顺序

-   优先处理高优先级中断
-   同级中断根据任意的顺序

![](https://pic2.zhimg.com/80/v2-4467a838bf2c8b71b2188108123ca849_hd.jpg)

-   当多个中断同时到达是首先处理高优先级的中断再处理低优先级的中断。

  

-   中断嵌套处理

-   在处理低优先级中断时允许高优先级中断发生
-   保证高优先级中断被及时处理

![](https://pic3.zhimg.com/80/v2-6ba78aba2e6a9c2f9b22d9666e41390a_hd.jpg)

  

-   中断向量表

-   中断/异常处理的重要数据结构

-   引导CPU转向相应的中断或异常处理程序
-   每个表项称为一个中断向量

-   中断ID作为中断向量表项的索引

![](https://pic1.zhimg.com/80/v2-a4e45608ee8b1e1da0d5867bc2fa09a0_hd.jpg)

如上图所示，就是中断处理的数据结构表示，其中 PC1 记录的就是中断处理程序的入口地址。PSW中预先设置好了中断/异常处理程序需要的处理机执行状态。

  

-   中断响应（中断进入）

-   中断响应是当CPU发现已有中断请求时，暂停现行程序执行，并自动引出中断处理程序的过程。

![](https://pic1.zhimg.com/80/v2-ed0b7094b23842ae38660db961e2e278_hd.jpg)

-   保护现场和恢复现场

-   现场： 在中断的那一时刻能确保程序继续运行的有关信息

-   下一条指令的地址（PC 寄存器的值）
-   程序运行所处的状态（PSW 的值）
-   指令执行情况
-   程序执行的中间结果等

-   保护现场：响应中断时，必须立即把现场信息保存在主存中

-   硬件：PS（其中存放PSW）和PC
-   中断/异常处理程序（软件）

-   所有通用寄存器
-   需要的其他信息：中断/异常ID、错误码等

-   恢复现场：

-   被中断程序重新运行之前，把之前保留的该程序现场信息从主存中送至相应的寄存器中。
-   中断/异常处理程序：通用寄存器
-   iret指令：PS和PC

-   中断/异常响应过程：

-   硬件：在每条指令执行结束时，检测是否有中断/异常的发生。如果有，就完成下面的中断/异常响应过程：

-   将当前PS和PC存入临时寄存器中；
-   根据中断ID找到相应的中断向量单元：

-   PSW -> PS （完成从用户态到核心态的转变）
-   处理程序入口 -\> PC （完成从用户栈道核心栈的切换）

-   切换到核心栈
-   临时寄存器中的PS和PC存入核心栈。
-   开始执行中断/异常处理程序。

-   软件：当硬件完成了中断进入过程后，由相应的中断处理程序得到控制权，进入了软件的中断处理过程。

![](https://pic4.zhimg.com/80/v2-7855fa42a0892cd00389f421373ce5df_hd.jpg)

软件继续保留被中断进程的现场信息，因为 CPU 还有除了 PS 和 PC 的一组通用寄存器需要进行保存。之后执行相应的中断服务例程。执行完成后恢复被中断进程的现场信息（保存在核心栈和进程控制块内的现场信息）。再由中断返回指令，将 CPU 的 PS 和 PC 寄存器的值写入 CPU 的两个寄存器，让 CPU 继续运行之前被中断的进程。



## 1.5. 系统调用

应用程序与OS的接口，在应用程序中使用系统调用。

系统功能调用是用户在程序一级请求操作系统服务的一种手段，它是带有一定功能号的“访管指令”。访管指令是由硬件提供的一条机器指令，但是其功能是由操作系统中的程序完成的，即由软件方法实现的。

-   系统调用流程

![](https://pic3.zhimg.com/80/v2-64b1be0ad3a24865dd9e507be37e366a_hd.jpg)

在应用程序中需要在显示器上显示一串字符，那么需要使用C语言中的 printf 函数，在 printf函数中包含了一条访管指令 0x80， 这条访问指令其实就是发出一条软中断信号，让 CPU 执行 int 0x80 的中断处理程序。这条中断处理程序对应的就是内核中的 system_call 。按照我们之前讲解的中断处理程序的执行过程执行 0x80 的中断处理程序。

-   系统调用处理程序： system_call()

-   系统调用处理程序 system_call() 执行 int 0x80 异常的处理程序，是所有程序调用的入口点。其所完成的主要工作是：

-   宏SAVE_ALL保护现场；
-   正确性检查 ；
-   依eax中所包含的系统调用号，调用其对应的服务例程：

```text
call *SYMBOL_NAME(sys_call_table)(0,%eax,4) // eax 存放的是系统调用号

```

-   系统服务例程结束时，通过宏RESTORE_ALL恢复寄存器；
-   最后通过iret指令返回。

-   系统调用号

-   linux中，每个系统调用被赋予一个唯一的系统调用号
-   系统调用号定义在include/asm-i386/unistd.h头文件中
-   系统调用号格式如下：

```text
       #define  __NR_restart_syscall         0
       #define  __NR_exit		     1
       #define  __NR_fork	             2
       #define  __NR_read	             3
       #define  __NR_write	             4
       #define  __NR_open	             5
       …………
       #define  __NR_fremovexattr           237

```

-   系统调用入口表

-   系统调用表记录了内核中所有已注册过的系统调用，它是系统调用的跳转表。
-   系统调用表是一个函数指针数组，表中依次保存所有系统调用的函数指针。
-   Linux系统调用表保存在arch/i386/kernel/下的entry.S中。


-   系统调用参数传递

-   寄存器传递

-   eax：系统调用号
-   ebx, ecx, edx, esi和edi按照顺序存放前五个参数

-   系统调用执行流程

![](https://pic3.zhimg.com/80/v2-f60a3edc9a58e90acb9649d08981665e_hd.jpg)


和王道很不一样详尽的进程内容介绍，不一定会考试！

进程控制块内容
进程标识符：内部标识符（整数，表示进程）、外部标识符（字符串，用户对进程的标识符）
处理机状态信息：
通用寄存器；（32位CPU有8个32位的通用寄存器EAX、EBX、ECX、EDX、ESI、EDI、EBP和ESP）
段寄存器；（段寄存器是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成。32位CPU有6个，16位CPU有4个）
指令计数器；（存在下一条要执行的指令的地址）
程序状态字(PSW)；（中断允许位、陷入标志、任务嵌套标志、特权标志、溢出标志、符号标志、零标志、进位标志等）
进程调度信息：
进程状态；
进程优先级；
事件；
其他信息
进程控制信息：
程序和数据地址；
进程同步和通信信息；
资源清单；
链接指针















# 2. 学习推荐

作者：happywei
链接：https://www.zhihu.com/question/270998611/answer/360487210
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

强推网易云课堂上，哈工大李治军老师的os。让你懂原理的同时对linux0.11进行改动。被虐了之后爽的要死233333<img src="https://pic4.zhimg.com/v2-9bd8df0323c1f42b7c72ae868cc3f1ff_b.jpg" data-rawwidth="1304" data-rawheight="759" data-caption="" data-size="normal" class="origin_image zh-lightbox-thumb" width="1304" data-original="https://pic4.zhimg.com/v2-9bd8df0323c1f42b7c72ae868cc3f1ff_r.jpg">配套的实验环境在实验楼 操作系统原理与实践_Linux_实验楼 - 实验楼<img src="https://pic1.zhimg.com/v2-653508705daeaed44426288e8ebfa2d4_b.jpg" data-rawwidth="1459" data-rawheight="1348" data-caption="" data-size="normal" class="origin_image zh-lightbox-thumb" width="1459" data-original="https://pic1.zhimg.com/v2-653508705daeaed44426288e8ebfa2d4_r.jpg">如果是自己的ubuntu的话。这里有大佬配好的环境。DeathKing/hit-oslab​github.com这还有一个学长的gitbook和源码hoverwinter/HIT-OSLab​github.com突然发现了个有意思的事情，我要留作当纪念哈哈哈<img src="https://pic4.zhimg.com/v2-b35b73b25b5192ef57ed8e75fa5e50a3_b.jpg" data-rawwidth="1080" data-rawheight="825" data-size="normal" data-default-watermark-src="https://pic4.zhimg.com/v2-05d1e18cf683f42c9990650464123ddf_b.jpg" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic4.zhimg.com/v2-b35b73b25b5192ef57ed8e75fa5e50a3_r.jpg">编辑于 2018-04-29





为啥没人推学堂在线上的清华大学的操作系统课？是学堂在线没名气吗。。。这门课有23讲，理论有14讲，实验有9讲。实验做的是清华他们自己推出的ucore，大概有一万多行代码，不过大多数是写好的，看就行了，每次实验课后需要填一小部分代码。看到有人说难度比较大，我也觉得难度比较大，尤其是实验一和实验二，有时间的话可以慢慢磨，不要急于求成。顺便献丑一下我在GitHub上这个实验课的代码库：清华大学ucore_os_lab我把这门课过了一遍，在实验要填的代码和一些其他地方，我写了一些中文注释（可能会有理解不当的地方），方便我自己理解和回顾。我本来是想再完整的做一次实验的，但是考研开始复习了，没什么时间做一整个，贴出我的代码库也是想让大家提出问题，可以一起查缺补漏。

作者：风不会停息
链接：https://www.zhihu.com/question/270998611/answer/360563591
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。













计算机组成原理，体系结构，操作系统，计算机I/O系统（涵盖PCIE、SAS、USB），计算机图形学基础（涵盖2D、3D渲染原理，GPU加速原理），超级计算机和并行计算、计算机发展史、数字电路基础、芯片制造原理、等等，一本书就够了，《大话计算机》。


作者：Cascade
链接：https://www.zhihu.com/question/20706264/answer/17004815
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

学这门课程之前，要先忘掉这门课程名字中的“计算机”三个字。每节课，每个课程阶段都会介绍一种电路。从简单到复杂，从开关到ALU。每个阶段做出来的东西看起来都和“计算机”没什么关系，除了他们都能存储和运算。但是会很清楚的了解到每个阶段做出来的东西其实完全没有“存储”和“运算”功能。他们只不过是一种电路的状态，或者通过一个信号，控制另一部分电路的状态。由于很简单，很容易弄清楚这个东西是如何工作的。最后把所有东西拼成一块CPU的时候，就像你趴在地上拼拼图，拼完最后一块起身俯视的感觉。会了解到高低电平是如何通过各种门电路变成数据，变成屏幕上花花绿绿的程序的。这就是所谓的“原理”。这门课完全可以用一个词来概括，就是“抽象”。在我看来这也是整个计算机设计中所蕴含的的灵魂。其实一个门电路完全不知道自己在做什么，不过是按照电气特性把高电平变成低电平，低电平变成高电平。是人们把这些不同的状态抽象出0和1的概念，然后从中产生了“逻辑门”。并用此来表达逻辑运算，然后用这些逻辑运算去表示二进制的数值运算，再把这些运算组合起来，用一组开关来启动，就有了一条指令，最终把这些简单的电路变成了CPU。整个过程不过是一层一层的抽象。上层依赖于下层所提供的功能与意义，完成本身的功能同时又提供了更高层次的抽象。最后你从上挖到下，最底下的一层根本找不到什么0或1 。包括操作系统和各种协议，绝大部分计算机相关的东西都是这么一层层抽象出来的。这就是“计算机”“组成”的“原理”。友情提示，理论课可以逃，但实验课绝对不能逃。不知道你们的实验课做的是什么，我们是用VHDL写程序，然后烧到一个FPGA试验台里面。由于我的理论课老师每次课程要花至少三分之二的时间给我们讲西游记的处世哲学，所以我基本没怎么上过。但实验课一次没逃过，就算因故缺勤也会自己找老师补上。我感觉算法也好，理论也好，玩具也好，如果自己不亲自拆一遍再装回去，就没办法深刻理解它们是怎么跑起来的。
























作者：暗灭
链接：https://www.zhihu.com/question/58408219/answer/156866958
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

第一 计算机组成原理在讲什么，对于程序员来说的意义是什么。第二 哪些知识点是工作中经常遇到的。第三 在哪里学习，怎么学习。 第一 计算机组成原理在讲什么


计算机组成原理，讲述的多数跟硬件有关系，主要描述的是计算机的内部结构是什么，数据怎么存储和运算，指令系统又是什么，CPU怎么运转，还有就是输入输出是什么。


揭开神秘的面纱，做一个真正的工程师，计算机组成原理是必不可少，软件是灵魂，硬件是肉身，玄幻小说中经常说的肉身成圣，对应到IT里，指的就是对计算机组成原理非常熟悉。


计算机组成原理会讲很多底层的东西，大部分和编程无关，但是有一些重要的概念是少不了的。
这也是这个回答想要做到的，就是帮助新人快速了解哪些知识点很重要。




对于程序员来说，了解计算机组成原理，从认知上，就把软件从一个魔性的位置降低到了可掌控的位置，就会明白，软件运转并不是靠魔性，而是靠指令，所有你看到的数据和错误，都是对应的程序分解成一道道的指令。


除此之外，还有一些对于软件编程来讲非常重要的概念，特别是底层的一些设计理念。
所谓的科班出身，就从这里开始。




第二 哪些知识点是工作中经常遇到的。 1.浮点数的表示


   浮点数的表示是编程里比较重要的概念，这对于金融计算来讲，格式重要。1/3=多少？为什么推荐使用BigDecimal？
   Float和Double适合做金融运算么？


   这些都会在浮点数里找到答案，对于Java，Android，IOS，JS都有用。


2.进制


   1024的世界外行人不懂，没有2进制就没有计算机。这也是必不可少的一定要理解的概念。10000这个可不是联通的电话，8进制，16进制的转换对于运维来讲格外重要，如果你们熟悉Windows蓝屏，那一串看不懂的东西，也是和2二进有关。


    同样的，Java，Android，IOS，JS和OP都需要。


 


3 字符编码


   Ascii码，GB2312，GBK，Utf8，Unicode，这些编码格式，是缠绕程序员的恶梦，有一位未来的伟人曾经说过，如果一个程序员没有解决过乱码问题，他还能称为一个程序员吗？


   了解了这些编码的存储格式，你才会明白为毛为有中文乱码问题，究竟计算机是哪里出错了-其实错的是它么？它只是听你的话而已。
 
   这个对于Java程序来讲更重要一些，无论是DB，还是文件，还是接口，还是日志，甚至是CRT，只要有中文的地方，你都有可能遇到乱码的问题。


4.Cache的替换算法


   计算机本身的缓存设计，给软件系统中的缓存设计能提供很多启发。常用的替换算法，随机，FIFO，LRU，这些都是从计算机组成原理就可以借鉴的。


   当然最重要的还是缓存的概念，在计算机的世界里，空间换时间，时间换空间也是经常用的策略。
 
   能够理解了缓存，就能够让你在未来的复杂设计中站稳脚根。对于Android，IOS，JS也讲，也同样如此，Java更不用说，Redis和Memcache和Ehcache和OSCache等一系列缓存体系，都脱胎于最根本的计算机组成原理思想，只是在不同的场景下，有了自己的变异。


   对于缓存，还有命中率的概念要懂的。另外就是失效策略，命中率和失效策略是设计缓存的关键点。


5.总线


  总线的概念其实在几年前SOA盛行的时候比较火热，最近已经慢慢消散，但是做为背景知识，理解总件，进而理解微服务，还是有点用处的。




6.调用子程序


   调用子程序可以帮助你理解递归，回调。特别是在JS里，回调简直是。。。还有IOS。
   与此同时，上下文的概念也可以在调用子程序中理解的更透彻一些，想当年，我可是想了好久都没弄懂上下文是什么意思。


 
7.I/O


  IO更多的是一个概念，input和Output是一个非常重要的概念，特别是在网络请求和读文件中。
  Java工程师必备，Android和IOS也可以懂一点。JS可以不用怎么了解。




 
 




 第三 在哪里学习，怎么学习。


这些基础课程，最好的学习方式就是课本，我找到的一本王道考研，<计算机专业基础综合考试指导全书>








理论加实践，而且课程节奏很好。比如讲完系统调用，你就可以试着给xv6加个timer调用；讲完threads，你就可以试着给xv6加个系统调用，然后让这个系统支持线程...Lab实现的jOS和xv6有很多设计决策不同，对比它们你可以更好的理解什么是操作系统；当然能自己亲手写一些代码感觉会很不一样（理论怎么转换到实践）几点体会：homework也许比Lab更有启发性(我是这么认为的)；如果看过CSAPP就最好了，汇编都不用学了，shell也会写了，memory也了解了。6.828有个作业提交系统，只要邮箱就能注册了，然后可以互评Lab...

作者：Bohao23
链接：https://www.zhihu.com/question/27871198/answer/38472866
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

想学的话，我可以帮助你，毕竟大三过来人，上届操作系统课唯一动了手的那个人。现在我也还在继续写，需要帮助的话可以q我源代码  https://github.com/xhd2015/x2  主页有我的联系方式，不在这透露了。今天下午刚写完内存分配，所以过来答一波  首答，希望有帮助UPDATED：xhd2015/rsp3-armv8-baremetal  毕设项目，仍然是一个操作系统，但是设计上要更清晰。

作者：Fulton Shaw
链接：https://www.zhihu.com/question/57257819/answer/152490198
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


要把计算机组成原理、汇编语言、C语言、操作系统原理统一起来理解，现代的操作系统基本上都是类UNIX操作系统（包括Windows这个蹩脚的操作系统），UNIX和C是共同诞生的。可惜国内能讲好计算机组成原理的教材很少，不少课程开成了“晶体管计算机组成原理”。推荐《PC/Pentium实用技术指南》能补充很多IBM PC的早期历史和架构知识。有什么用？因为汇编语言往往会被教成IBM PC (8086)汇编语言，和当前的x86_64，甚至IA32都有距离。两个方法：一、背下来。至少知道进程管理、内存管理、设备管理和文件系统管理。考试还是要应付的；二、实验《Linux内核0.11(0.95)完全注释》。其代码基于IBM PC AT 386、软驱和AT硬盘。最后，能把操作系统原理、计算机组成原理和编译原理统一起来理解，才算修成正果。推荐《计算机系统要素——从零开始构建现代计算机系统》。最后，读《计算机图形学原理及实践 C语言描述 第二版》和《TCP/IP详解》。图形和网络是计算机中最重要的两个被操作系统管理的IO设备。

作者：lophyxp
链接：https://www.zhihu.com/question/58278825/answer/511770423
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



作者：Frostfall
链接：https://www.zhihu.com/question/58278825/answer/354467784
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

操作系统本身是个系统学科，所以肯定会有大量的概念，而且概念之间可能根本就不存在什么对应。但是我们先可以把它拆成几个简单的三个部分：进程模型，内存管理，文件系统。想想日常生活中操作系统为你做了些什么事。你打开电脑无非是浏览文件（看课件，看视频，听音乐），编程，玩游戏之类的事情。操作系统如何在机器上为你提供这些支持？为了能够浏览文件，你得能运行各种各样的程序来以某些格式来访问文件吧，你看这里就牵扯到了进程/线程模型（让程序以何种形式运行起来）和文件系统（如何访问持久化的数据），那这些程序要那些资源才能运行起来？这就牵扯到了内存管理（内存这种珍贵的资源如何分配和回收），文件系统，驱动（本质上是为文件系统提供与外界交互的支持），网络等。于是现在我们有了操作系统最重要的三个东西：进程/线程，文件系统，内存管理。把这三个东西推广出去：进程线程本质上为了你能够同时进行多个任务，也就是并发（concurrency），文件系统本质上是提供了持久化存储的使用，也就是持久化（persistence），内存管理本质上是公共资源管理，常用管理手段之一虚拟化（virtulization）。对，这三个点就是Operating system: Three easy pieces的出发点和重点讲述的东西。也是操作系统怎么都绕不开的三个东西。操作系统最后实现出来的进程线程模型，虚拟内存，文件系统，驱动，安全管理，分布式系统，网络文件系统等等复杂的问题，都只是这三点的发散和具象以及对特定。抓住这三个点，明白每一个知识点中提到的技术提供了哪个方面的支持，解决了什么问题，整个学习的过程就会非常轻松而且愉快。比如进程线程模型使得哪怕单核CPU也能在有限的资源上并发多个不同的进程/线程，于是你可以听着音乐刷知乎；虚拟内存让并发能够在内存极为受限的情况下依然运行十分消耗内存的程序，于是你可以玩动辄数G的大型游戏；文件系统让你可以用很人性化的方式控制复杂难用的磁盘，于是你不需要数着扇区去读写文件。网络借助文件系统可以向你提供统一的访问借口，于是你可以用socket来进行网络通信。不知道这么说会不会让你觉得操作系统其实是一个很有条例和结构的东西。另外，学校课程肯定都会配备相应的实验课，认真去上，自己独立地完成每一行代码，会让你对操作系统的理解大大加深。


















