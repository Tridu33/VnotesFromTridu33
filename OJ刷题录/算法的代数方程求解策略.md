# 算法的代数方程求解策略








算法的代数求解策略:
 算法多解其实是代数结构的泛函方程式，要求答案的恒等式约束下，必定存在对偶解，于是算法就有对偶的多种写法。
 最高级的算法求解思路不是 pddl 搜索，不是 buttom-up 自底向上指数搜索，这样是无脑枚举指数搜索，不可计算问题哥德尔不完备定律。要么启发式取巧搜索prolog，要么概率性随机游走或者马尔可夫链机器学习接受一个局部最优解，要么力大砖飞无脑强搜，都不美。从出发点上做法就是错的。 最危险的是这样做的话，没有正确性保证，不能通过枚举无数种情况验证，除非QNP那些可数无穷种测例可以通过”充分测例集“来实现完全遍历，否则就算通过当前所有测例，算法也是不安全的，没有正确性保证。从实例中规约很直观，提取抽象很正常，但是不够正确，不够可靠。
 一个微妙的点是 “如果已知目标解算法的CFG,充分实例集遍历算法路径很好给出”，问题是我们不知道目标问题的通用解，假设这类问题满足一个通用解，则充分实例集不好给。只能反过来生成的时候验证一把确实是充分实例集。

 因此，需要**纯代数角度**出发，从 top-down 假设解必须满足的恒等式(难点在于把答案要求的性质形式化为代数式)，原问题形式化的代数系统演算规则，
 然后求解方程不动点泛函，得到“算法解函数”。
 
 参考Y组合子不动点方程求解，动态规划不变量不等式求解，贪心拟阵求解，Haskell[二分法](https://leetcode.cn/problems/binary-search/solutions/2287037/zhe-ti-shi-er-fen-fa-checkhan-shu-hen-ha-41dh/)形式化的代数求解......(多做几个例子，超越例子的抽象，格洛腾迪克不推荐用例子思考问题),参考《算法新解》perls of pure functional programming language
 
 问题形式化过程中，需要描述一级抽象解函数的高级抽象，需要范畴学，求解泛函，求解方程不动点，循环不变量守恒量。
 甚至《算法导论》可以证明比较排序的复杂度上限n*log(n),类似地，也能证明存在某个代数结构的解函数中的“最优解上界”，运筹学规划器。
 甚至，算法等效计算图CFG的\beta 规约范式，自动实现“自动机=>记忆性递归=>DP不变量的变换”算法生成等价转换。这些优点都是深度规范，代数化求解的好处。























