# CS刷题Notes





## 先python形式化搞明白数学公式思路，然后c++代码

[https://cyc2018.github.io/CS-Notes/#/README](https://cyc2018.github.io/CS-Notes/#/README)







[https://cyc2018.github.io/CS-Notes/#/notes/Leetcode%20题解%20-%20目录1](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%951)

POJ题目分类 http://www.pythontip.com/acm/problemCategory










1. 基本的数据结构和算法工具要会用：

对于模板，比如大树、回溯、图的深度优先搜索和广度优先搜索、动态规划、贪心算法。

一次刷一定量的题，方便类比和查缺补漏，总结规律。

acm文件输入输出测试小技巧 


2. 算法类型分门别类地刷题

枚举enumeration：遍历（穷举）解空间寻找解。可以利用数学约束减小需要搜索的解空间，以好的次序遍历等方法优化

搜索search：从解空间中一点出发，以特定的次序遍历结构化的解空间（如图）

打表table markdown ：把（原问题或子问题）解空间中的部分结果保存下来，以空间换时间

倍增：保留 [公式] 处的值以快速构造所有的情况

迭代iteration：从解空间中一点出发，保证每次都向解“靠近”，最终收敛到解

递推Inductive ：从较小规模的问题出发，获得原问题的解。递推和递归可以比作综合法和分析法，动态规划的实现既可以用递归（记忆化搜索）也可以用递推（Bottom-up）

>迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。(数值计算，不动点函数)
递推：从初值出发反复进行某一运算得到所需结果。-----从已知到未知，从小到达（比如每年长高9cm，20年180，30后270）递推算法是一种用若干步可重复的简运算（规律）来描述复杂问题的方法。递推是序列计算机中的一种常用算法。它是按照一定的规律来计算序列中的每个项，通常是通过计算机前面的一些项来得出序列中的指定象的值。
递归：从所需结果出发不断回溯前一运算直到回到初值再递推得到所需结果----从未知到已知。程序调用自身的编程技巧称为递归。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。 https%3A//math.stackexchange.com/questions/228863/recursive-vs-inductive-definition
链接：https://www.zhihu.com/question/20651054/answer/175142676


递归recursion：将原问题规约到一个较小规模的问题上（甚至从规模 n 到规模 n-1，当然这可以用循环实现，这里的递归是数学上的设计而非需要栈帧的递归）以下的分治法、动归等都是在递归的基础上，基于解空间的特性设计的更好的方法




分治：将原问题规约到多个规模相近的问题上。首先划分（Divide），再用相同方法解决子问题（Conquer），最后合并子问题的答案获得（Merge）

二分：无需 Merge 的分治法，通常在划分的两个子问题空间中，原问题的解落在确定的一个子问题内部

动态规划：原问题的 最优 解可以由子问题的最优解组合而成（optimal sbustructure）。相比于分治，动态规划在每步采取不同的划分策略（make a decision）会导致不同的结果（快排在哪里划分不会影响正确性），程序上体现在最外层的循环。其优点在于可以避免反复求解相同的子问题（overlapping subproblem）

贪心：原问题的 最优 解可以通过局部最优的策略（decision）规约到一个较小规模的问题上。可以看做是在动态规划中存在一种最优的划分子问题的方案

图论算法：图的引入使为了更好的结构化问题，理解解空间，主要是利用上面的算法设计，针对不同的问题设计出的算法，不再展开















