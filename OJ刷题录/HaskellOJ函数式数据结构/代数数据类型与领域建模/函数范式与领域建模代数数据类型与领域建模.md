# 1. 基于代数的api设计 -为领域服务设计代数结构-类型的最终代数

>架构大师Christopher Alexander启发《SoftwarePartterns》：一个模式就是一篇文学作品，他描述了一个设计问题以及在一个特定上下文中该问题的通用解决方按。
>Alexander也说过"每个模式都是由三块内容组成的一个规则;它反映的是某个上下文、问题、解决方按。这三者之间的关系。"


本文函数时模块提供OO更好的可重用性：

1. 完全通用且可重用的代码[代数]
2. 特定上下文的实现。在所有应用模式的实例中各有不同，称之为“代数的解释程序”

https://www.youtube.com/watch?v=pMuiVlnGqjk Evans作者谈DDD



6:22 例子
    7:38 货运系统设计的弊端
    7:50 软件设计的2个观点
        8:01 观点1：软件设计者
            8:32 货运系统的副作用
                8:43 将复杂的逻辑与数据库更新结合在一起违反了将逻辑与更新状态分开的原则
        9:08 另一个角度：领域
            9:58 更多详情， 10:02 我们不能总是得到如此高层次的讨论
    11:01 我们想要的是能够在发生这种情况时注意到并采取正确的措施 11:18 它会如何影响现有软件 
    11:46 我们必须找到另一种应对方式
14:15 DDD的原则之一：语言非常重要 14:21我注意到的一件事：在谈论软件时，我们使用的语言与软件中所使用的语言不同




《函数响应式编程》
P76描述monad的实际含义：



```
在函数式编程中，我们将计算声明为表达式，一个表达式可以是简单表达式，也可以是多个表达式的组合。

当我们把领域行为 建模为领域模型的时候，同时也实现了组合器，用类似的方法进化演变。
我们从简单函数开始，然后使用高阶函数的威力，组合成更加大的抽象。一个monad抽象了计算的一个类型。用于建立这种组合器的基本库。

一个monad由三部分组成：
1. 一个类型构造器M【A】 ，Scala中一般表示为trait M[A] ,case class M[A].或者class M[A];
2. 一个unit方法，将一个计算引入monad。在Scala中使用类构造器的调用实现这个目的
3. 一个bind方法，他将计算序列化。在scala中，FlatMap就是这个bind，。


这就暗示了monad是一个代数结构，任何拥有这三个元素的monad同样需要遵守以下三个原则:
1. 一致性identity:对于一个单子m,m Flatmap unit => m
2. 单元性unit:对于一个单子m,unit(v) flatMap f =>f(v)
3. 组合性associativity:对于一个单子m,m flatMap g flatMap h => m flatMap(x=>g(x) flatMap h)
```










# 2. 代数数据类型与领域建模,局部用函数全局用OO
代数数据类型与对象范式的抽象数据类型有着本质的区别。前者体现了数学计算的特性，具有不变性。使用Scala的case object或case class语法糖会帮助我们创建一个不可变的抽象。


由于Income被定义为和类型，它表达的是一种逻辑**或**的关系，因此它的每个子类型（称为ADT变体）都将成为模式匹配的分支。和类型的组合有着确定的值（类型理论的术语将其称之为inhabitant），例如Income和类型的值为3，则模式匹配的分支就应该是3个，这就使得Scala编译器可以检查模式匹配的穷尽性。

http://zhangyi.xyz/fp-and-domain-model/
函数范式与领域建模









<Funcitonal 暗大Reactive Domain modeling>

函数响应式领域编程

DSLs in Action




函数范式

REA的Ken Scambler认为函数范式的主要特征为：模块化（Modularity），抽象化（Abstraction）和可组合（Composability）。这三个特征可以帮助我们编写简单的程序。

通常，为了降低系统的复杂度，都需要将系统分解为多个功能的组成部分，每个组成部分有着清晰的边界。模块化的编码范式需要支持实现者能够轻易地对模块进行替换，这就要求模块具有隔离性，避免在模块之间出现太多的纠缠。函数范式以“函数”为核心，作为模块化的重要组成部分。函数范式要求函数均为没有副作用的纯函数（pure function）。在推断每个函数的功能时，由于函数没有产生副作用，就可以不考虑该函数当前所处的上下文，形成清晰的隔离边界。这种相互隔离的纯函数使得模块化成为可能。

函数的抽象能力不言而喻，因为它本质上是一种将输入类型转换为输出类型的转换行为。任何一个函数都可以视为一种转换(transform)，这是对行为的最高抽象，代表了类型（type）之间的某种动作。极端情况下，我们甚至不用考虑函数的名称和类型，只需要关注其数学本质：f(x) = y。其中，x是输入，y是输出，f就是极度抽象的函数。

**函数范式领域模型的核心要素为代数数据类型（Algebraic Data Type, ADT）和纯函数。**代数数据类型表达领域概念，纯函数表达领域行为。由于二者皆被定义为不变的、原子的，因此在类型的约束规则下可以对它们进行组合。可组合的特征使得函数范式建立的领域模型可以由简单到复杂，利用组合子来表现复杂的领域逻辑。

代数数据类型

代数数据类型借鉴了代数学中的概念，作为一种函数式数据结构，体现了函数范式的数学意义。通常，代数数据类型不包含任何行为。它利用和类型（Sum Type）来展示相同抽象概念的不同组合，使用积类型（Product Type）来展示同一个概念不同属性的组合。



面向对象的建模方法是一种归纳法，通过分析和归纳需求，找到问题域并逐级分解问题，然后通过对象来表达领域逻辑，并以职责的角度分析这些领域逻辑，按照角色把职责分配给各自的对象，通过对象之间的协作实现复杂的领域行为。面向组合子的建模方法则是一种**演绎法**，通过在领域需求中寻找和定义最基本的原子操作，然后根据基本的组合规则将这些原子类型与原子函数组合起来。



Debasish Ghosh总结了函数范式的基本原则，用以建立更好的领域模型：

>利用函数组合的力量，用小函数组装成一个大函数，获得更好的组合性。

>纯粹，领域模型的很多部分都由引用透明的表达式组成。

>通过方程式推导，可以很容易地推导和验证领域行为。

不止如此，根据代数数据类型的不变性以及对模式匹配的支持，它还天生适合表达领域事件。例如地址变更事件，就可以用一个积类型来表示：


函数范式可以很好地与事件驱动架构结合在一起，这是一种以领域事件作为模型驱动设计的驱动力思想。针对事件进行建模，则任何业务流程皆可用状态机来表达。状态的迁移，就是命令（command）或者决策（decision）对事件的触发。我们还可以利用事件风暴（Event Storming）帮助我们识别这些事件，而事件的不变性特征又可以很好地与函数式编程结合起来。



如果采用命令查询职责分离（CQRS）模式，那么在命令端，将由命令与事件组成一系列异步的非阻塞消息流。这种对消息的认识，恰好可以与响应式编程（Reactive Programming）结合起来。诸如ReactiveX这样的响应式编程框架在参考了迭代器模式与观察者模式的基础上，结合了函数式编程思想，以事件处理的形式实现了异步非阻塞处理，在满足系统架构灵活性与伸缩性的同时，提高了事件处理的响应能力。

显然，围绕着不变的事件为中心，包括响应式编程、事件风暴、事件溯源与命令查询职责分离模式都可以与函数范式有效地结合起来，形成一种**事件模型驱动设计(Event Model Driven Design, EDDD)**方法。与事件驱动架构不同，事件模型驱动设计可以算是领域驱动设计的一种分支。作为一种设计方法学，它的实践与模式同样涵盖了战略设计与战术设计等多个层次，且可以与领域驱动设计的模式如限界上下文、领域事件、领域服务等结合起来。在金融、通信等少数领域，已经开始了对这种建立在函数范式基础之上的领域驱动设计的尝试，与它们相关的知识可以写成厚厚的一本大书，在这里就不再赘述了。







# 3. 函数范式领域模型的核心要素为代数数据类型（Algebraic Data Type, ADT）和纯函数。

**代数数据类型表达领域概念，纯函数表达领域行为。**

由于二者皆被定义为不变的、原子的，因此在类型的约束规则下可以对它们进行组合。可组合的特征使得函数范式建立的领域模型可以由简单到复杂，利用组合子来表现复杂的领域逻辑。


https://cloud.tencent.com/developer/article/1442060

代数数据类型与领域建模



REA的Ken Scambler认为函数范式的主要特征为：模块化（Modularity），抽象化（Abstraction）和可组合（Composability）。这三个特征可以帮助我们编写简单的程序。


代数数据类型借鉴了代数学中的概念，作为一种函数式数据结构，体现了函数范式的数学意义。通常，代数数据类型不包含任何行为。它利用**和类型**（Sum Type）来展示相同抽象概念的不同组合，使用**积类型**（Product Type）来展示同一个概念不同属性的组合。

和与积是代数中的概念，它们在函数范式中体现了类型的两种组合模式。和就是加，用以表达一种类型是它的所有子类型之和。


积类型体现了一个代数数据类型是其属性组合的笛卡尔积，例如一个员工类型：





和类型和积类型的这一特点体现了代数数据类型的组合（combinable）特性。


代数数据类型既体现了领域概念的知识，同时还通过和类型和积类型定义了约束规则，从而建立了严格的抽象。

例如类型组合(String, String, Date)是一种高度的抽象，但它却丢失了领域知识，因为它缺乏类型标签，如果采用积类型方式进行定义，则在抽象的同时，还约束了各自的类型。

和类型在约束上更进了一步，它将变化建模在一个特定数据类型内部，并限制了类型的取值范围。

**和类型与积类型结合起来，与操作代数数据类型的函数放在一起，然后利用模式匹配来实现表达业务规则的领域行为。**





Robert Martin在《敏捷软件开发》一书中给出的薪资管理系统需求为例，利用函数范式的建模方式来说明**代数数据类型的优势**。需求描述如下：



>公司雇员有三种类型。一种雇员是钟点工，系统会按照雇员记录中每小时报酬字段的值对他们进行支付。他们每天会提交工作时间卡，其中记录了日期以及工作小时数。如果他们每天工作超过8小时，超过部分会按照正常报酬的1.5倍进行支付。支付日期为每周五。
>月薪制的雇员以月薪进行支付。每个月的最后一个工作日对他们进行支付。在雇员记录中有月薪字段。
>销售人员会根据他们的销售情况支付一定数量的酬金（Commssion）。他们会提交销售凭条，其中记录了销售的日期和数量。在他们的雇员记录中有一个酬金报酬字段。每隔一周的周五对他们进行支付。






```
// ADT定义，体现了领域概念
// Amount是一个积类型，Currency则为前面定义的和类型
calse class Amount(value: BigDecimal, currency: Currency) {
   // 实现了运算符重载，支持Amount的组合运算
  def +(that: Amount): Amount = {
     require(that.currency == currency)
    Amount(value + that.value, currency)
  }
  def *(times: BigDecimal): Amount = {
    Amount(value * times, currency)
  }
}

// 以下类型皆为积类型，分别体现了工作时间卡与销售凭条领域概念
case class TimeCard(startTime: Date, endTimeDate)
case class SalesReceipt(date: Date, amount: Amount)

// 支付周期是一个隐藏概念，不同类型的雇员支付周期不同
case class PayrollPeriod(startDate: Date, endDate: Date)

// Income的抽象表示成和类型与乘积类型的组合
sealed trait Income
case class WeeklySalary(feeOfHour: Amount, timeCards: List[TimeCard], payrollPeriod: PayrollPeriod) extends Income
case class MonthlySalary(salary: Amount, payrollPeriod: PayrollPeriod) extends Income
case class Commission(salary: Amount, saleReceipts: List[SalesReceipt], payrollPeriod: PayrollPeriod)

// Employee被定义为积类型，它组合的Income具有不同的抽象
case class Employee(number: String, name: String, onboardingDate: Date, income: Income)
```





-----------------------------------------------------------------

领域模型与代数数据类型（第一期） - DDD-China的文章 - 知乎
https://zhuanlan.zhihu.com/p/127128213



领域模型与代数数据类型（第三期） - DDD-China的文章 - 知乎
https://zhuanlan.zhihu.com/p/129804129

领域模型与代数数据类型（第四期） - DDD-China的文章 - 知乎
https://zhuanlan.zhihu.com/p/130786398

领域模型与代数数据类型（完结篇） - DDD-China的文章 - 知乎
https://zhuanlan.zhihu.com/p/134037627









《领域驱动设计15年》第8章
https://www.zhihu.com/column/ddd-china 
领域驱动设计中国（DDD-China）
















































