# 与或短路与否cpp




https://www.jianshu.com/p/5472726983c6







结论：“或”逻辑前面为1，“与”逻辑前面为0就会发生短路  
1——或逻辑短路

# include <stdio.h>

int main()  
{  
int a=5,b=6,c=7,d=8,m=2,n=2;  
(m=a<b)||(n=c>d);  
printf("%d\\t%d",m,n);  
}  
输出的结果为1,2.为什么呢，因为a<b，m=1,这个“或”逻辑就被“短路”掉了，后面的语句就没被执行，所以n还是等于原先的2  
｜｜只要有一个为１，结果就为１。因此短路.并且不计算（n=c>d);  
2——与逻辑短路

# include <stdio.h>

int main()  
{  
int a=5,b=6,c=7,d=8,m=2,n=2;  
(m=a>b)&&(n=c>d);  
printf("%d\\t%d",m,n);  
}  
输出的结果为0,2。因为a>b为0，m=0，整个“与”逻辑判断就为“假”，所以后面的“c>d”就被短路掉了，所以n还是等于原先的2  
＆＆只要有一个为０，都为０.因此计算机不计算(n=c>d);

另附：别人总结  
逻辑与(&)和逻辑或(|)：  
标准的逻辑与(&)和逻辑或(|)，不论第一个表达式为true or false，都计算第二个表达式。  
例如：if (c==0 | e++ < 100) { d=12;} //不论c是否等于0，e都被自增量。

2.  短路与(&&)和短路或(||)  
    A&&B, 当A为false时，不去计算B的值而直接返回false；当A为true时，计算B的值。  
    A || B，当A为true时， 不去计算B的值而直接返回true；当A为false时，计算B的值。

3.应用比较  
短路&& 是很有用的。例如，下面的程序语句说明了短路逻辑运算符的优点，用它来防止被0除的错误：  
if (denom != 0 && num / denom > 10)  
既然用了短路与(&&) 运算符，就不会有当denom为0时产生的意外运行时错误。如果该行代码使用标准与 运算符（&），它将对两个运算数都求值，当出现被0除的情况时，就会产生运行时错误。

```undefined
     既然短路运算符在布尔逻辑运算中有效，那么就在布尔逻辑运算中全用它，而标准的AND 和OR运算符（只有一个字符）仅在位运算中使用。

```

4.  Java四大运算符：算术运算符、位运算、关系运算、逻辑运算  
    另外还有比较运算符(instanceof)
    
    ```java
        A>     算术与位运算就不说了,一般不容易出错
    
        B>     关系运算符:   ==    >     <     <=    >=    !=
                    关系运算的结果为boolean,只有true和false，不像C/C++中，非0为true，0为false。
                    boolean flag= a<c;  //这种写法是正确的.
                    例如: if(a == b) {}     //如果是正确的,进行运算; 
    
                    赋值运算符 = 是赋值的,  如: int a = 5;        //不是 int a == 5;
    
        C>     布尔逻辑运算符
                  布尔逻辑运算的运算数只能是布尔型，结果也为boolean型
    
                   逻辑与(&)和逻辑或(|)  及   短路与(&&)和短路或(||) 的区别见上。
    
    ```
    








