# 1. FFP


[http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki-ebook/dp/B00AKE1V04](https://link.zhihu.com/?target=http%3A//www.amazon.com/Purely-Functional-Structures-Chris-Okasaki-ebook/dp/B00AKE1V04)

题主你应该看这本书。函数式语言有自己独有的数据结构，《算法导论》上面的算法基本废掉，只能留下指导思想了。所以不是什么概念直接替换一下就可以的，你应该重头学。

  
  
作者：vczh  
链接：https://www.zhihu.com/question/39221590/answer/80259716  
来源：知乎  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。





函数式编程能否解决所有经典的算法问题？ \- Yunfei Lu的回答 - 知乎 https://www.zhihu.com/question/39221590/answer/80518221

















我的结论是：可以，因为图灵完备性。但函数式编程对递归数据结构的算法问题效果较好，对需保存状态的以及需要随机地址存取的数据结构效果较差。因为函数式编程的算法是递归的，递归数据结构与递归算法天生就很相配。  
算法与数据结构是分不开的。数据结构的核心是引用与解引用。  
例如树结构，struct tree_node{ parent, left, right }，left与right是两个从干到枝的引用，parent是从枝到干的引用。对一般的操作，递归都很方便。但是红黑树就有麻烦了，因为有状态，而不是简单的引用与解引用的问题。改变状态，在函数式编程特别是纯函数式编程里面就是天大的事，因为可能是一个对象的生灭。  
再举例看list数据结构和map、filter这样的高阶函数。map、filter需要利用list的递归数据结构：struct list{ car, cdr }。map和filter的操作是先解引用car用一个函数f操作，把剩余cdr部分和map或filter打包到递归函数里面。但是如果要随机存取呢？比如直接取第100个元素？如果不改变list结构的底层（指的是list的寻址方式由递归改成随机寻址），那么就是非常困难的。map结构的key如果不能随机寻址，map就没有存在的必要了。  
最后举一个例子：丘奇数。丘奇数是递归定义的自然数，加减乘除靠递归算法实现。实在不如小学生的九九表来得直接。  
回到问题本身，若要强行用递归算法解决一切算法问题，需要先针对问题设计一个好的递归数据结构。比如红黑树问题，也许转变成2-3-4树更方便一点？（猜测）  
为什么有这么大的区别，我觉得因为从汇编码的随意goto到命令式的if/else/while，再到函数式的递归，抽象的概念越来越清晰，但是威力越来越受限制。人理解起来容易，但机器会觉得被绑住了手脚。对于确定的算法，最快的是专用集成电路ASIC，最慢的是CPU和编程语言。







  
作者：Runtian Zhou  
链接：https://www.zhihu.com/question/39221590/answer/80326309  
来源：知乎  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。




从lambda calculus和图灵机的等价性来说，显然是可行的。可问题是值得这样去做么？FP带来的一个很大的优势是便于进行多线程操作，而事实上，之前学的很多算法，比如dijkstra,prim,kruskal,tarjan这一系列基于DFS的图论算法都是完全sequencial的。对于这些算法，用FP写既不方便，又不高效。由于没有变量，你需要把所有的副作用全部打包在函数的参数中，并以tuple的形式返回结果，这种逻辑上的转换其实对你对FP以及算法本身基本是没啥大用的，不过给你绕了个大圈子。如果不信的话可以试试看在FP里面写一遍tarjan，迭代器的设计就可以累死人了2333。但是个人认为FP还是很适合去写一些数据结构的，pattern match的特性真的能省不少事，所以总而言之，FP虽好，但有些不适合FP写的算法也别强求自己，写出来真是一包气lol

  
















