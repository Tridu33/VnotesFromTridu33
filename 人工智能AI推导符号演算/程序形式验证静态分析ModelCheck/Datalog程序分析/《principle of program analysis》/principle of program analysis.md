

http://www.imm.dtu.dk/~hrni/PPA/summary.html









本书对程序分析的原理进行了介绍。它着重于四种主要方法（数据流分析，控制流分析，抽象解释以及类型和效果系统），以指示它们之间的关系和差异。它本身涵盖了多种编程语言功能。我们将对算法技术进行广泛的介绍，为方程式和约束求解的快速算法提供统一的方法。

阐述的水平假设编程语言（包括语义和编译器）具有一定的背景知识。该演示文稿针对的是研究生，但请记住，它对于初学者也应是有用的，并且基础部分应由高级本科生阅读。此外，该领域的研究人员和实践人员可能会因为对所有主要方法的广泛涵盖而发现了这本书，从而突显了它们之间存在的许多相似之处。

该书包含六章，三个附录，术语和符号索引以及参考书目。每章包含许多练习，而本书则包含几个小型项目，使学生可以更详细地探索开发的各个部分。

### 第一章：简介

本章的目的是通过展示命令式和功能式程序分析的启发性示例来说明这四种方法的基本性质。这不仅将突出强调一些稍后将要详细处理的问题，还将为以后的讨论建立参考框架；特别是，它可以使读者欣赏这四种方法之间的许多*相似之处*（与阅读文献可能给人的印象相反）。接下来，我们介绍第一个非常简单的算法来计算分析结果。它可以看作是后续章节中要开发的几种算法的基础。最后，我们说明了如何使用程序分析信息进行程序转换。

### 第2章：数据流分析

我们从对活动变量，可用表达式，到达定义，非常忙碌的表达式，ud-chain和du-chain的经典过程内分析的处理开始，从而解释*前进*和*后退*之间的区别分析。接下来，我们为命令式语言提供了结构化的操作语义，并证明了实时变量分析的语义正确性；一个小型项目展示了如何证明到达定义分析的语义正确性。然后，我们介绍Kam和Ullman单调框架提供的一般化；我们将常数传播分析公式化为分布式框架中没有的分析示例。然后，我们提出了用于计算单调框架的MFP解决方案的通用工作列表算法，并且我们讨论了MFP解决方案可能与MOP解决方案有所不同。

然后，我们继续进行数据流分析的一些更复杂的方面。我们详细讨论了过程间分析的各种技术，包括调用字符串（la Sharir和Pnueli）和假设集（la Landi和Ryder）。最后一部分将进行分析，确定所指向的图是否专门针对非循环甚至是树，最后以提出更雄心勃勃的形状分析作为结束。

### 第三章：控制流分析

我们为一种简单的无类型功能语言开发了控制流分析（也称为闭包分析）。这可以看作是过程间数据流分析的产物，因为现在我们解决了``动态调度''问题。它需要的意味着什么的结果的抽象coinductive规范的形式的0-CFA（或单变）分析是可接受的。接下来，我们为该语言提供结构化的操作语义，并证明该规范在语义上是合理的。我们还表明，通过建立关于一组解决方案的总体结果，规范始终接受最佳解决方案。摩尔家庭。然后，我们展示如何以显式形式生成约束，以及如何使用基于图的算法来计算立方时间中的最小解。这与关于集合约束的文献有关。

我们通过处理一些更复杂的方面来完成本章。一种是添加数据流组件（例如，以单调框架的形式），从而显示如何合并来自过程内分析的思想。另一个是通过调用字符串（*k* -CFA的一个变体，称为uniform- *k* -CFA）的方式合并上下文，从而建立了过程间分析的链接。

### 第四章：抽象解释

为了说明抽象解释的一般性质，我们将不关注任何特定的语言或语义。为此，我们抽象地将正确性表述为在计算过程中保留一定的正确性关系。然后，我们处理用于``加速''最小固定点的计算（实际上是``超调''）的*加宽*和*变窄*的重要技术。接下来，我们讨论*伽罗瓦连接*的经典技术（或附加），将一个Universe上的计算替换为一个更粗糙的Universe上的计算。我们将详细介绍如何以系统的方式构建Galois连接，涵盖诸如独立属性方法与关系方法，直接乘积与张量乘积以及这些构造的简化版本之类的技术。最后，我们展示了如何``推导''要在较粗的域上执行的实际计算; 其中包括对如何``引发''扩展的处理，我们将展示如何在第2章的单调框架的情况下应用这些思想。通过许多示例，我们将展示如何开发Webber近似来将索引检查为数组（在PLDI'97上展示）。

### 第5章：类型和效果系统

本章首先为第3章中讨论的控制流分析的变体建立类型和效果系统；这也有助于引入次效应。接下来，我们证明所指定的信息相对于自然语义（或大步结构操作语义）在语义上是正确的；按照第3章的方式，我们还表明始终存在最佳分析。然后，我们展示了如何通过生成约束来有效地执行分析。这涉及证明算法*W*（在lambda演算中用于类型推断）版本的句法合理性和完整性。

为了说明类型和效果系统的多样性，我们通过为简单功能语言制定其他几种类型和效果系统来得出结论。首先，我们展示如何指定副作用分析，这涉及子类型的讨论。然后，我们进行逃逸分析，这涉及多态性的讨论。接下来，我们讨论区域分析并简要讨论多态递归。最后，我们开发了一个简单的指针分析，该分析比第2章中介绍的分析更为粗略（且速度更快）。

### 第6章：算法

我们首先考虑简单约束系统的解决方案（例如数据流分析中的方程式或简单不等式）。我们提供了第2章和第3章中使用的工作清单算法的通用版本。我们表明，对于某些分析，循环算法可能更有效。对于每种算法，我们给出正确性结果并讨论复杂性。

### 附录A：部分有序集

本附录介绍了将在本书中使用的部分有序集的关键定义和结果。这包括塔斯基（Tarski）的结果（其中包括）：完整晶格上的单调函数具有最小固定点和最大固定点。

### 附录B：归纳法和共归法

本附录概述了本书中使用的主要归纳原理。它还在第3章中介绍了协导的证明原理（基于Tarski的结果），该原理用于开发控制流分析。

### 附录C：图和正则表达式

本附录介绍了图形和正则表达式的概念，这些概念构成了第6章介绍的算法的基础。其中包括诸如深度优先生成树，反向后置和按区间可约化的概念。











# 1. principle of program analysis




https://github.com/StarGazerM/ppa-in-code




























