# python一行执行命令

1、通过标准输入和管道
因为如何用管道传东西给一个进程是属于 shell 的内容，我不打算深入解释。毋庸置疑，你可以将代码传递到 Python 中。

管道传内容给 python
echo "print('hi')" | python
如果将文件重定向到 Python，这显然也可以。



通过-c 指定的字符串
```
python -c "print('hi')"
```



```
python spam.py
```


对包使用 -m
执行 Python 包的正确方法是使用 -m 并指定要运行的包名。

python -m spam
它在底层使用了runpy [5]。要在你的项目中做到这点，只需要在包里指定一个__main__.py 文件，它将被当成__main__ 执行。而且子模块可以像任何其它模块一样导入，因此你可以对其进行各种测试。

我知道有些人喜欢在一个包里写一个main 子模块，然后将其__main__.py 写成：

```python
from . import main

if name == "__main__":

main.main()
```


就我个人而言，我不感冒于单独的main 模块，而是直接将所有相关的代码放入__main__.py ，因为我感觉这些模块名是多余的。

（译注：即作者不关心作为入口文件的"main"或者“__main__”模块，因为执行时只需用它们的包名即可。我认为这也暗示了入口模块不该再被其它模块 import。我上篇文章 [6]比作者的观点激进，认为连那句 if 语句都不该写。）


6、执行一个压缩文件
如果你确实有多个文件和/或依赖模块，并且希望将所有代码作为一个单元发布，你可以用一个__main__.py ，放置在一个压缩文件中，并把压缩文件所在目录放在 sys.path 里，Python 会替你运行__main__.py 文件。

将一个压缩包传给 Python
python app.pyz
人们现在习惯上用 .pyz 文件扩展名来命名此类压缩文件，但这纯粹是传统，不会影响任何东西；你当然也可以用 .zip 文件扩展名。

为了简化创建此类可执行的压缩文件，标准库提供了zipapp [7]模块。它会为你生成__main__.py并添加一条组织行（shebang line），因此你甚至不需要指定 python，如果你不想在 UNIX 上指定它的话。如果你想移动一堆纯 Python 代码，这是一种不错的方法。

不幸的是，仅当压缩文件包含的所有代码都是纯 Python 时，才能这样运行压缩文件。执行压缩文件对扩展模块无效（这就是为什么 setuptools 有一个 zip_safe [8]标志的原因）。（译注：扩展模块 extension module，即 C/C++ 之类的非 Python 文件）

要加载扩展模块，Python 必须调用 dlopen() [9]函数，它要传入一个文件路径，但当该文件路径就包含在压缩文件内时，这显然不起作用。

我知道至少有一个人与 glibc 团队交谈过，关于支持将内存缓冲区传入压缩文件，以便 Python 可以将扩展模块读入内存，并将其传给压缩文件，但是如果内存为此服务，glibc 团队并不同意。

但是，并非所有希望都丧失了！你可以使用诸如shiv [10]之类的项目，它会捆绑（bundle）你的代码，然后提供一个__main__.py 来处理压缩文件的提取、缓存，然后为你执行代码。尽管不如纯 Python 解决方案理想，但它确实可行，并且在这种情况下算得上是优雅的。


















