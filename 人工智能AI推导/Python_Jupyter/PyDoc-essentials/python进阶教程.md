# 1. python进阶教程



https://docs.pythontab.com/interpy/


1.1. [1.0 *args 和 **kwargs](https://docs.pythontab.com/interpy/args_kwargs/README/)
1.2. [1.1 *args 的用法](https://docs.pythontab.com/interpy/args_kwargs/Usage_args/)
1.3. [1.2 **kwargs 的用法](https://docs.pythontab.com/interpy/args_kwargs/Usage_kwargs/)
1.4. [1.3 使用 *args 和 **kwargs 来调用函数](https://docs.pythontab.com/interpy/args_kwargs/Using_args_and_kwargs_to_call_function/)
1.5. [1.4 什么时候使用它们](https://docs.pythontab.com/interpy/args_kwargs/When_to_use/)
1.6. [2.0 调试 Debugging](https://docs.pythontab.com/interpy/Debugging/README/)
1.7. [3.0 生成器 Generators](https://docs.pythontab.com/interpy/Generators/README/)
1.8. [3.1 可迭代对象(Iterable)](https://docs.pythontab.com/interpy/Generators/Iterable/)
1.9. [3.2 迭代器(Iterator)](https://docs.pythontab.com/interpy/Generators/Iterator/)
1.10. [3.3 迭代(Iteration)](https://docs.pythontab.com/interpy/Generators/Iteration/)
1.11. [3.4 生成器(Generators)](https://docs.pythontab.com/interpy/Generators/Generators/)
1.12. [4.0 Map，Filter和Reduce](https://docs.pythontab.com/interpy/Map_Filter/README/)
1.13. [4.1 Map](https://docs.pythontab.com/interpy/Map_Filter/Map/)
1.14. [4.2 Filter](https://docs.pythontab.com/interpy/Map_Filter/Filter/)
1.15. [4.3 Reduce](https://docs.pythontab.com/interpy/Map_Filter/Reduce/)
1.16. [5.0 set 数据结构](https://docs.pythontab.com/interpy/set_data_structure/set_data_structure/)
1.17. [6.0 三元运算符](https://docs.pythontab.com/interpy/ternary_operators/ternary_operators/)
1.18. [7.0 装饰器](https://docs.pythontab.com/interpy/decorators/README/)
1.19. [7.1 一切皆对象](https://docs.pythontab.com/interpy/decorators/everything_is_object/)
1.20. [7.2 在函数中定义函数](https://docs.pythontab.com/interpy/decorators/def_func_in_func/)
1.21. [7.3 从函数中返回函数](https://docs.pythontab.com/interpy/decorators/return_func_in_func/)
1.22. [7.4 将函数作为参数传给另一个函数](https://docs.pythontab.com/interpy/decorators/func_as_argument/)
1.23. [7.5 你的第一个装饰器](https://docs.pythontab.com/interpy/decorators/your_first_decorator/)
1.24. [7.5.1 使用场景](https://docs.pythontab.com/interpy/decorators/use_cases/)
1.25. [7.5.2 授权](https://docs.pythontab.com/interpy/decorators/auth/)
1.26. [7.5.3 日志](https://docs.pythontab.com/interpy/decorators/logging/)
1.27. [7.6 带参数的装饰器](https://docs.pythontab.com/interpy/decorators/deco_with_args/)
1.28. [7.6.1 在函数中嵌入装饰器](https://docs.pythontab.com/interpy/decorators/nest_deco_in_func/)
1.29. [7.6.2 装饰器类](https://docs.pythontab.com/interpy/decorators/deco_class/)
1.30. [8.0 Global和Return](https://docs.pythontab.com/interpy/global_return/README/)
1.31. [8.1 多个return值](https://docs.pythontab.com/interpy/global_return/multiple_return_values/)
1.32. [9.0 对象变动 Mutation](https://docs.pythontab.com/interpy/Mutation/README/)
1.33. [10.0 __slots__魔法](https://docs.pythontab.com/interpy/slots_magic/README/)
1.34. [11.0 虚拟环境](https://docs.pythontab.com/interpy/virtual_environment/virtual_environment/)
1.35. [12.0 容器 Collections](https://docs.pythontab.com/interpy/collections/collections/)
1.36. [13.0 枚举 Enumerate](https://docs.pythontab.com/interpy/Enumerate/Enumerate/)
1.37. [14.0 对象自省](https://docs.pythontab.com/interpy/introspection/README/)
1.38. [14.1 dir](https://docs.pythontab.com/interpy/introspection/dir/)
1.39. [14.2 type和id](https://docs.pythontab.com/interpy/introspection/type_and_id/)
1.40. [14.3 inspect模块](https://docs.pythontab.com/interpy/introspection/inspect/)
1.41. [15.0 推导式 Comprehension](https://docs.pythontab.com/interpy/Comprehensions/README/)
1.42. [15.1 列表推导式](https://docs.pythontab.com/interpy/Comprehensions/list-comprehensions/)
1.43. [15.2 字典推导式](https://docs.pythontab.com/interpy/Comprehensions/dict-comprehensions/)
1.44. [15.3 集合推导式](https://docs.pythontab.com/interpy/Comprehensions/set-comprehensions/)
1.45. [16.0 异常](https://docs.pythontab.com/interpy/exception/README/)
1.46. [16.1 处理多个异常](https://docs.pythontab.com/interpy/exception/multiple_exception/)
1.47. [16.2 finally从句](https://docs.pythontab.com/interpy/exception/finally_clause/)
1.48. [16.3 try/else从句](https://docs.pythontab.com/interpy/exception/try_else_clause/)
1.49. [17.0 lambda表达式](https://docs.pythontab.com/interpy/Lambdas/README/)
1.50. [18.0 一行式](https://docs.pythontab.com/interpy/Onelines/README/)
1.51. [19.0 For - Else](https://docs.pythontab.com/interpy/for_else/README/)
1.52. [19.1 else语句](https://docs.pythontab.com/interpy/for_else/else_clause/)
1.53. [20.0 使用C扩展](https://docs.pythontab.com/interpy/c_extensions/README/)
1.54. [20.1 CTypes](https://docs.pythontab.com/interpy/c_extensions/ctypes/)
1.55. [20.2 SWIG](https://docs.pythontab.com/interpy/c_extensions/swig/)
1.56. [20.3 Python/C API](https://docs.pythontab.com/interpy/c_extensions/python_c_api/)
1.57. [21.0 open函数](https://docs.pythontab.com/interpy/open_func/open_func/)
1.58. [22.0 目标Python2+3](https://docs.pythontab.com/interpy/TargetingPython2+3/README/)
1.59. [23.0 协程](https://docs.pythontab.com/interpy/Coroutines/README/)
1.60. [24.0 函数缓存](https://docs.pythontab.com/interpy/func_caching/README/)
1.61. [24.1 Python 3.2+](https://docs.pythontab.com/interpy/func_caching/python_32/)
 1.62. [24.2 Python 2+](https://docs.pythontab.com/interpy/func_caching/python_2/)
1.62. [25.0 上下文管理器](https://docs.pythontab.com/interpy/context_managers/README/)
1.63. [25.1 基于类的实现](https://docs.pythontab.com/interpy/context_managers/implement_as_class/)
1.64. [25.2 处理异常](https://docs.pythontab.com/interpy/context_managers/handle_exception/)
1.65. [25.3 基于生成器的实现](https://docs.pythontab.com/interpy/context_managers/implement_as_generator/)
   
    
    

 python深浅复制




**对于不可变对象的深浅拷贝**

```text
import copy
a=(1,2,3)

print("=====赋值=====")
b1=a
print(a)
print(b1)
print(id(a))
print(id(b1))

print("=====浅拷贝=====")
b2=copy.copy(a)
print(a)
print(b2)
print(id(a))
print(id(b2))

print("=====深拷贝=====")
b3=copy.deepcopy(a)
print(a)
print(b3)
print(id(a))
print(id(b3))
```

结果：

```text
=====赋值=====
(1, 2, 3)
(1, 2, 3)
43481128
43481128
=====浅拷贝=====
(1, 2, 3)
(1, 2, 3)
43481128
43481128
=====深拷贝=====
(1, 2, 3)
(1, 2, 3)
43481128
43481128
```

不可变对象类型，没有被拷贝的说法，即便是用深拷贝，查看id的话也是一样的，如果对其重新赋值，也只是新创建一个对象，替换掉旧的而已。

一句话就是，不可变类型，不管是深拷贝还是浅拷贝，地址值和拷贝后的值都是一样的。

  

**对于可变对象深浅拷贝**

```text
import copy
a=[1,2,3]

print("=====赋值=====")
b=a
print(a)
print(b)
print(id(a))
print(id(b))

print("=====浅拷贝=====")
b=copy.copy(a)
print(a)
print(b)
print(id(a))
print(id(b))

print("=====深拷贝=====")
b=copy.deepcopy(a)
print(a)
print(b)
print(id(a))
print(id(b))
```

结果：

```text
=====赋值=====
[1, 2, 3]
[1, 2, 3]
37235144
37235144
=====浅拷贝=====
[1, 2, 3]
[1, 2, 3]
37235144
37191432
=====深拷贝=====
[1, 2, 3]
[1, 2, 3]
37235144
37210184
```

赋值： 值相等，地址相等

copy浅拷贝：值相等，地址不相等

deepcopy深拷贝：值相等，地址不相等

  

**对于可变对象深浅拷贝(外层改变元素)**

```text
import copy
l=[1,2,3,[4, 5]]

l1=l #赋值
l2=copy.copy(l) #浅拷贝
l3=copy.deepcopy(l) #深拷贝
l.append(6)

print(l)  
print(l1)
print(l2)
print(l3)
```

结果：

```text
[1, 2, 3, [4, 5], 6]     #l添加一个元素6
[1, 2, 3, [4, 5], 6]     #l1跟着添加一个元素6
[1, 2, 3, [4, 5]]        #l2保持不变
[1, 2, 3, [4, 5]]        #l3保持不变
```

  

  

**对于可变对象深浅拷贝(内层改变元素)**

```text
import copy
l=[1,2,3,[4, 5]]

l1=l #赋值
l2=copy.copy(l) #浅拷贝
l3=copy.deepcopy(l) #深拷贝
l[3].append(6) 

print(l) 
print(l1)
print(l2)
print(l3)
```

结果：

```text
[1, 2, 3, [4, 5, 6]]      #l[3]添加一个元素6
[1, 2, 3, [4, 5, 6]]      #l1跟着添加一个元素6
[1, 2, 3, [4, 5, 6]]      #l2跟着添加一个元素6
[1, 2, 3, [4, 5]]         #l3保持不变
```

1.外层添加元素时，浅拷贝不会随原列表变化而变化；内层添加元素时，浅拷贝才会变化。  
2.无论原列表如何变化，深拷贝都保持不变。  
3.赋值对象随着原列表一起变化。


Python中的赋值(复制)、浅拷贝与深拷贝 - 晚来天御雪的文章 - 知乎
https://zhuanlan.zhihu.com/p/54011712


[http://c.biancheng.net/view/5358.html](http://c.biancheng.net/view/5358.html)



python tutor运行一遍马上清晰



1.66. with

with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭／线程中锁的自动获取和释放等。






1.67. 问题引出

如下代码：

```
file = open("１.txt")
data = file.read()
file.close()
```

上面代码存在２个问题：  
（１）文件读取发生异常，但没有进行任何处理；  
（２）可能忘记关闭文件句柄；

1.68. 改进

```
try:
    f = open('xxx')
except:
    print('fail to open')
    exit(-1)
try:
    do something
except:
    do something
finally:
    f.close()
```

虽然这段代码运行良好，但比较冗长。  
而使用with的话，能够减少冗长，还能自动处理上下文环境产生的异常。如下面代码：

```
with open("１.txt") as file:
    data = file.read()
```


所以，还是用`with`语句来得保险：

```
with open('/Users/michael/test.txt', 'w') as f:
    f.write('Hello, world!')
```

要写入特定编码的文本文件，请给`open()`函数传入`encoding`参数，将字符串自动转换成指定编码

blog.kissdata.com/2014/05/23/python-with.html











1.69. 自省反射







1.70. 抽象基类AbstractBaseClass







1.71. 元编程

















































































































