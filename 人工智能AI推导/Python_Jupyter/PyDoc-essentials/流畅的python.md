# 1. 流畅的pytohn





FluentPython








源码

https://www.github.com/fluentpython/example-code


第二版

https://github.com/fluentpython/example-code-2e


并发编程python

https://github.com/fluentpython/concurrency2019






**《流畅的Python》图书目录**

第一部分 序幕  
第1章 Python 数据模型 2  
1.1 一摞 Python 风格的纸牌 3  
1.2 如何使用特殊方法 6  
1.2.1 模拟数值类型 7  
1.2.2 字符串表示形式 9  
1.2.3 算术运算符 10  
1.2.4 自定义的布尔值 10  
1.3 特殊方法一览 10  
1.4 为什么 len 不是普通方法 12  
1.5 本章小结 12  
1.6 延伸阅读 13  
第二部分 数据结构  
第2章 序列构成的数组 16  
2.1 内置序列类型概览 17  
2.2 列表推导和生成器表达式 18  
2.2.1 列表推导和可读性 18  
2.2.2 列表推导同 filter 和 map 的比较 20  
2.2.3 笛卡儿积 20  
2.2.4 生成器表达式 21  
2.3 元组不仅仅是不可变的列表 22  
2.3.1 元组和记录 23  
2.3.2 元组拆包 23  
2.3.3 嵌套元组拆包 25  
2.3.4 具名元组 26  
2.3.5 作为不可变列表的元组 27  
2.4 切片 28  
2.4.1 为什么切片和区间会忽略最后一个元素 28  
2.4.2 对对象进行切片 29  
2.4.3 多维切片和省略 30  
2.4.4 给切片赋值 31  
2.5 对序列使用 + 和 * 31  
2.6 序列的增量赋值 33  
2.7 list.sort 方法和内置函数 sorted 36  
2.8 用 bisect 来管理已排序的序列 37  
2.8.1 用 bisect 来搜索 38  
2.8.2 用 bisect.insort 插入新元素 40  
2.9 当列表不是首选时 41  
2.9.1 数组 41  
2.9.2 内存视图 44  
2.9.3 NumPy 和 SciPy 45  
2.9.4 双向队列和其他形式的队列 47  
2.10 本章小结 49  
2.11 延伸阅读 50  
第3章 字典和集合 54  
3.1 泛映射类型 54  
3.2 字典推导 56  
3.3 常见的映射方法 57  
3.4 映射的弹性键查询 61  
3.4.1 defaultdict ：处理找不到的键的一个选择 61  
3.4.2 特殊方法 \_\_missing\_\_ 62  
3.5 字典的变种 65  
3.6 子类化 UserDict 65  
3.7 不可变映射类型 67  
3.8 集合论 68  
3.8.1 集合字面量 69  
3.8.2 集合推导 71  
3.8.3 集合的操作 71  
3.9 dict 和 set 的背后 73  
3.9.1 一个关于效率的实验 74  
3.9.2 字典中的散列表 75  
3.9.3 dict 的实现及其导致的结果 78  
3.9.4 set 的实现以及导致的结果 80  
3.10 本章小结 80  
3.11 延伸阅读 81  
第4章 文本和字节序列 83  
4.1 字符问题 84  
4.2 字节概要 85  
4.3 基本的编解码器 88  
4.4 了解编解码问题 89  
4.4.1 处理 UnicodeEncodeError 90  
4.4.2 处理 UnicodeDecodeError 90  
4.4.3 使用预期之外的编码加载模块时抛出的 SyntaxError 91  
4.4.4 如何找出字节序列的编码 92  
4.4.5 BOM：有用的鬼符 93  
4.5 处理文本文件 94  
4.6 为了正确比较而规范化 Unicode 字符串 99  
4.6.1 大小写折叠 101  
4.6.2 规范化文本匹配实用函数 102  
4.6.3 极端“规范化”：去掉变音符号 103  
4.7 Unicode 文本排序 105  
4.8 Unicode 数据库 108  
4.9 支持字符串和字节序列的双模式 API 109  
4.9.1 正则表达式中的字符串和字节序列 109  
4.9.2 os 函数中的字符串和字节序列 111  
4.10 本章小结 112  
4.11 延伸阅读 113  
第三部分 把函数视作对象  
第5章 一等函数 118  
5.1 把函数视作对象 119  
5.2 高阶函数 120  
5.3 匿名函数 122  
5.4 可调用对象 122  
5.5 用户定义的可调用类型 123  
5.6 函数内省 124  
5.7 从定位参数到仅限关键字参数 126  
5.8 获取关于参数的信息 127  
5.9 函数注解 131  
5.10 支持函数式编程的包 132  
5.10.1 operator 模块 132  
5.10.2 使用 functools.partial 冻结参数 135  
5.11 本章小结 137  
5.12 延伸阅读 137  
第6章 使用一等函数实现设计模式 141  
6.1 案例分析：重构“策略”模式 142  
6.1.1 经典的“策略”模式 142  
6.1.2 使用函数实现“策略”模式 145  
6.1.3 选择最佳策略：简单的方式 148  
6.1.4 找出模块中的全部策略 149  
6.2 “命令”模式 150  
6.3 本章小结 151  
6.4 延伸阅读 152  
第7章 函数装饰器和闭包 154  
7.1 装饰器基础知识 155  
7.2 Python 何时执行装饰器 156  
7.3 使用装饰器改进“策略”模式 157  
7.4 变量作用域规则 159  
7.5 闭包 161  
7.6 nonlocal 声明 164  
7.7 实现一个简单的装饰器 165  
7.8 标准库中的装饰器 168  
7.8.1 使用 functools.lru_cache 做备忘 168  
7.8.2 单分派泛函数 170  
7.9 叠放装饰器 172  
7.10 参数化装饰器 173  
7.10.1 一个参数化的注册装饰器 173  
7.10.2 参数化 clock 装饰器 175  
7.11 本章小结 177  
7.12 延伸阅读 178  
第四部分 面向对象惯用法  
第8章 对象引用、可变性和垃圾回收 182  
8.1 变量不是盒子 183  
8.2 标识、相等性和别名 184  
8.2.1 在 == 和 is 之间选择 185  
8.2.2 元组的相对不可变性 186  
8.3 默认做浅复制 187  
8.4 函数的参数作为引用时 190  
8.4.1 不要使用可变类型作为参数的默认值 191  
8.4.2 防御可变参数 193  
8.5 del 和垃圾回收 195  
8.6 弱引用 196  
8.6.1 WeakValueDictionary 简介 197  
8.6.2 弱引用的局限 199  
8.7 Python 对不可变类型施加的把戏 199  
8.8 本章小结 201  
8.9 延伸阅读 201  
第9章 符合 Python 风格的对象 205  
9.1 对象表示形式 206  
9.2 再谈向量类 206  
9.3 备选构造方法 208  
9.4 classmethod 与 staticmethod 209  
9.5 格式化显示 210  
9.6 可散列的 Vector2d 213  
9.7 Python 的私有属性和“受保护的”属性 218  
9.8 使用 \_\_slots\_\_ 类属性节省空间 220  
9.9 覆盖类属性 222  
9.10 本章小结 224  
9.11 延伸阅读 225  
第10章 序列的修改、散列和切片 229  
10.1 Vector 类：用户定义的序列类型 230  
10.2 Vector 类第1 版：与 Vector2d 类兼容 230  
10.3 协议和鸭子类型 232  
10.4 Vector 类第2 版：可切片的序列 233  
10.4.1 切片原理 234  
10.4.2 能处理切片的 \_\_getitem\_\_ 方法 236  
10.5 Vector 类第3 版：动态存取属性 237  
10.6 Vector 类第4 版：散列和快速等值测试 240  
10.7 Vector 类第5 版：格式化 244  
10.8 本章小结 251  
10.9 延伸阅读 251  
第11章 接口：从协议到抽象基类 256  
11.1 Python 文化中的接口和协议 257  
11.2 Python 喜欢序列 258  
11.3 使用猴子补丁在运行时实现协议 260  
11.4 Alex Martelli 的水禽 262  
11.5 定义抽象基类的子类 266  
11.6 标准库中的抽象基类 267  
11.6.1 collections.abc 模块中的抽象基类 267  
11.6.2 抽象基类的数字塔 269  
11.7 定义并使用一个抽象基类 270  
11.7.1 抽象基类句法详解 273  
11.7.2 定义 Tombola 抽象基类的子类 274  
11.7.3 Tombola 的虚拟子类 276  
11.8 Tombola 子类的测试方法 278  
11.9 Python 使用 register 的方式 281  
11.10 鹅的行为有可能像鸭子 281  
11.11 本章小结 283  
11.12 延伸阅读 284  
第12章 继承的优缺点 289  
12.1 子类化内置类型很麻烦 289  
12.2 多重继承和方法解析顺序 292  
12.3 多重继承的真实应用 296  
12.4 处理多重继承 298  
12.5 一个现代示例：Django 通用视图中的混入 301  
12.6 本章小结 304  
12.7 延伸阅读 304  
第13章 正确重载运算符 307  
13.1 运算符重载基础 308  
13.2 一元运算符 308  
13.3 重载向量加法运算符 + 310  
13.4 重载标量乘法运算符 * 315  
13.5 众多比较运算符 318  
13.6 增量赋值运算符 321  
13.7 本章小结 325  
13.8 延伸阅读 326  
第五部分 控制流程  
第14章 可迭代的对象、迭代器和生成器 330  
14.1 Sentence 类第1 版：单词序列 331  
14.2 可迭代的对象与迭代器的对比 334  
14.3 Sentence 类第2 版：典型的迭代器 337  
14.4 Sentence 类第3 版：生成器函数 339  
14.5 Sentence 类第4 版：惰性实现 343  
14.6 Sentence 类第5 版：生成器表达式 344  
14.7 何时使用生成器表达式 345  
14.8 另一个示例：等差数列生成器 346  
14.9 标准库中的生成器函数 349  
14.10 Python 3.3 中新出现的句法： yield from 357  
14.11 可迭代的归约函数 358  
14.12 深入分析 iter 函数 359  
14.13 案例分析：在数据库转换工具中使用生成器 360  
14.14 把生成器当成协程 362  
14.15 本章小结 362  
14.16 延伸阅读 363  
第15章 上下文管理器和 else 块 368  
15.1 先做这个，再做那个： if 语句之外的 else 块 369  
15.2 上下文管理器和 with 块 370  
15.3 contextlib 模块中的实用工具 374  
15.4 使用 @contextmanager 375  
15.5 本章小结 378  
15.6 延伸阅读 378  
第16章 协程 381  
16.1 生成器如何进化成协程 382  
16.2 用作协程的生成器的基本行为 382  
16.3 示例：使用协程计算移动平均值 385  
16.4 预激协程的装饰器 386  
16.5 终止协程和异常处理 388  
16.6 让协程返回值 391  
16.7 使用 yield from 393  
16.8 yield from 的意义 398  
16.9 使用案例：使用协程做离散事件仿真 403  
16.9.1 离散事件仿真简介 403  
16.9.2 出租车队运营仿真 404  
16.10 本章小结 410  
16.11 延伸阅读 411  
第17章 使用期物处理并发 416  
17.1 示例：网络下载的三种风格 416  
17.1.1 依序下载的脚本 418  
17.1.2 使用 concurrent.futures 模块下载 420  
17.1.3 期物在哪里 421  
17.2 阻塞型 I/O 和 GIL 424  
17.3 使用 concurrent.futures 模块启动进程 424  
17.4 实验 Executor.map 方法 426  
17.5 显示下载进度并处理错误 429  
17.5.1 flags2 系列示例处理错误的方式 433  
17.5.2 使用 futures.as_completed 函数 435  
17.5.3 线程和多进程的替代方案 437  
17.6 本章小结 437  
17.7 延伸阅读 438  
第18章 使用 asyncio 包处理并发 442  
18.1 线程与协程对比 443  
18.1.1 asyncio.Future ：故意不阻塞 448  
18.1.2 从期物、任务和协程中产出 449  
18.2 使用 asyncio 和 aiohttp 包下载 450  
18.3 避免阻塞型调用 454  
18.4 改进 asyncio 下载脚本 456  
18.4.1 使用 asyncio.as_completed 函数 456  
18.4.2 使用 Executor 对象，防止阻塞事件循环 461  
18.5 从回调到期物和协程 462  
18.6 使用 asyncio 包编写服务器 466  
18.6.1 使用 asyncio 包编写 TCP 服务器 467  
18.6.2 使用 aiohttp 包编写 Web 服务器 471  
18.6.3 更好地支持并发的智能客户端 474  
18.7 本章小结 475  
18.8 延伸阅读 476  
第六部分 元编程  
第19章 动态属性和特性 482  
19.1 使用动态属性转换数据 483  
19.1.1 使用动态属性访问 JSON 类数据 485  
19.1.2 处理无效属性名 487  
19.1.3 使用 \_\_new\_\_ 方法以灵活的方式创建对象 488  
19.1.4 使用 shelve 模块调整 OSCON 数据源的结构 490  
19.1.5 使用特性获取链接的记录 493  
19.2 使用特性验证属性 498  
19.2.1 LineItem 类第1 版：表示订单中商品的类 498  
19.2.2 LineItem 类第2 版：能验证值的特性 499  
19.3 特性全解析 500  
19.3.1 特性会覆盖实例属性 501  
19.3.2 特性的文档 503  
19.4 定义一个特性工厂函数 504  
19.5 处理属性删除操作 506  
19.6 处理属性的重要属性和函数 507  
19.6.1 影响属性处理方式的特殊属性 507  
19.6.2 处理属性的内置函数 508  
19.6.3 处理属性的特殊方法 509  
19.7 本章小结 510  
19.8 延伸阅读 510  
第20章 属性描述符 514  
20.1 描述符示例：验证属性 514  
20.1.1 LineItem 类第3 版：一个简单的描述符 515  
20.1.2 LineItem 类第4 版：自动获取储存属性的名称 519  
20.1.3 LineItem 类第5 版：一种新型描述符 524  
20.2 覆盖型与非覆盖型描述符对比 526  
20.2.1 覆盖型描述符 528  
20.2.2 没有 \_\_get\_\_ 方法的覆盖型描述符 529  
20.2.3 非覆盖型描述符 530  
20.2.4 在类中覆盖描述符 531  
20.3 方法是描述符 531  
20.4 描述符用法建议 533  
20.5 描述符的文档字符串和覆盖删除操作 534  
20.6 本章小结 535  
20.7 延伸阅读 536  
第21章 类元编程 538  
21.1 类工厂函数 539  
21.2 定制描述符的类装饰器 541  
21.3 导入时和运行时比较 543  
21.4 元类基础知识 547  
21.5 定制描述符的元类 552  
21.6 元类的特殊方法 \_\_prepare\_\_ 554  
21.7 类作为对象 556  
21.8 本章小结 557  
21.9 延伸阅读 557  
结语 560  
附录 A 辅助脚本 563  
Python 术语表 588  
作者简介 600  
关于封面 600












