










**这个入门科普可以说六到飞起**

科普 - 程序验证（1）- 简介 - FRONTIERS的文章 - 知乎
https://zhuanlan.zhihu.com/p/295230186
# 1. z3程序验证

在**软件工程**（Software Engineering）领域，用于**确保程序正确性**的手段有很多，大体可分为两类：**动态方法**（Dynamic）和**静态方法**（Static）。 **动态方法**需要将软件源码**编译**，再通过特定的输入考察软件的**运行**结果。 动态方法中使用得比较广泛的是**软件测试**（Testing），有手动测试（手写Test Case）、自动化测试（如Fuzzing Test）等。 动态方法效率高，错误定位准确，但应用场合受限，它要求程序必须能运行起来。 而且，其最大的问题在于，动态方法不能覆盖程序的所有输入以及其对应的执行路径，故只能证明被测试所覆盖的**部分程序**没有问题，而**不能证明整个程序不存在错误**。 **静态方法**则是基于程序源**代码**进行，**不需要**编译运行，所以应用场景更加广泛。 常用的静态方法有**静态分析、符号执行、定理证明、程序验证**等等。 不同的静态方法各有优劣，其应用门槛也比较高，一般用于对程序正确性要求较高的场景。

常规的**静态分析**（Static Analysis）方法比较轻量级，适用于大规模代码，但比较大的问题是较高比例的**误报**（False Positive）。 所以静态分析报出的结果，需要逐一人工排查，从而导致耗费大量的人力资源。 静态分析引擎比较有名的是**Coverity**，目前已经实现较大规模商业化应用。 **符号执行**（Symbolic Execution）可以看作是更加准确的测试方法，它通过符号值来静态“执行”程序，积累**路径条件**（Path Condition），直到到达目标位置，再对路径条件进行**约束求解**（Constraint Solving），判断目标位置的**可达性**（Reachability）。 由于需要使用约束求解，而且对循环不友好，所以符号执行方法比较难以大规模应用。 符号执行比较经典的工具是**KLEE**。 **定理证明**（Theorem Proving）方法是使用**高阶逻辑**（High Order Logic，HOL）对程序及其需要满足的性质进行建模，然后使用机器辅助证明的方法，一步一步证明程序能够满足要求的性质。 定理证明方法主要的缺陷是需要大量的专业人工参与，编写证明代码，而且对软件的更新迭代不友好。 辅助定理证明的典型工具是**Coq**。

**程序验证**（Program/Software Verification）旨在**自动化**地证明程序的正确性，即程序在运行的过程中不会出错，并且程序的功能能够满足。 程序验证的优点是能够自动化地进行程序的正确性证明。 但其缺点也很显著，其一是对高阶功能属性不友好，一般用于证明一些低阶属性，比如程序中不存在“除0错误”，“指针的use after free”，“数组越界或缓冲区溢出”等等。 其二是程序验证一般也依赖于约束求解，所以同样难以直接大规模地应用。 但随着验证算法和约束求解引擎的不断进步，程序验证的可用性将变得越来越好。



程序验证的目的；

程序验证的基本要素；

程序验证的基本方法思路；

在以下的几个例子中，我们将使用以下的步骤进行程序验证：

1. 给出程序源码（Source Code）;
2. 标注我们需要验证的属性（Property/Specification）；
3. 将我们需要验证的问题转换为逻辑公式（Logic Formula）；
4. 证明逻辑公式的正确性（Correctness/Validity）；



- 交互两数字

 “等号”和“赋值”的区别。 针对这个问题，我们将程序转换为静态单赋值形式（Static Single Assignment Form，SSA）。 SSA顾名思义，即每个变量都仅会被定义和赋值一次。


借助于这样的方法，可以将“等号”和“赋值”不加区分地等同起来。从而，我们可以将SSA程序直接转化为逻辑公式




公式描述了，对于所有的变量，只要其值满足对输入的要求和程序的执行逻辑约束（蕴含运算的前提[公式]为真），那么在程序运行后，要求的属性也应该被满足（蕴含运算的结论[公式]为真）。因此，只要以上逻辑公式用SMT solver证明是永真的（Valid），那我们所要验证的属性也就是成立的。

**程序源码到SSA**是可以自动化进行的； 从**SSA到逻辑公式**也是可以自动化进行的； 而证明逻辑公式的正确性，也可以借助于约束求解器来自动进行。 所以，在程序验证中，我们只要提供**程序源码和描述属性的断言**，就可以通过自动化的方法，证明属性成立。


- 按大小排列两个整数


if条件分支语句





- 将某个数增加到N

程序验证对带循环程序的处理

循环不变式（Loop Invariant），即在任意多次循环执行后，这个式子始终是成立的。 有了这个信息，我们就可以使用循环不变式，来替代表示循环执行的效果，即循环的执行对程序变量的值的影响。 循环不变式意味着，不论循环执行多少次，对程序变量的值所造成的影响，都会在循环不变式所描述的范围内。

循环不变式还有另一层含义，即从循环之前的代码执行到循环头时，循环不变式也要成立。 这实际上可以看作是循环执行0次（即循环还未执行）的情况。

程序验证的基本要素是程序的源码，要验证的属性，这是实现自动化验证的前提。 同时，在必要时，我们需要有循环不变式。

最后，程序验证的**基本思路**是，在给定源码和属性的基础上，通过验证算法，将我们需要验证的问题转化为逻辑公式，再证明逻辑公式的正确性。




**z3 logic公式的化简**，离散数学中命题逻辑，一阶谓词逻辑



 以上几个例子展示了**最基础的验证算法**，它直接简单粗暴地将程序转化为逻辑公式进行求解。 

 事实上，还有很多巧妙的验证算法，

 比如：**谓词抽象**（Predicate Abstraction）、**路径抽象**（Path Abstraction）、**反例制导的抽象精化**（Counter-Example-Guided Abstraction and Refinement，CEGAR）、**[$k-$归纳算法**（[公式]-induction）等等。

 这些验证算法基本思想都很简洁巧妙，值得学习和了解












