编译器资源管理器是一种交互式工具，可让您在一个窗口中键入代码，并在另一窗口中查看其编译结果。

https://godbolt.org/ online


使用该站点应该是不言自明的：默认情况下，左侧窗格是源窗口，而右侧则具有程序集输出。

https://github.com/compiler-explorer

编译器资源管理器使您可以交互式地探索在编译器发挥了魔力之后C ++，C，D，Rust，Pascal和其他编译语言代码的结果。它显示了一个带注释的程序集窗口，并允许您调整代码和编译设置，并查看它如何影响输出。它还使您可以运行代码。

Compiler Explorer于2012年投入使用，已经从一个有趣的小网站（当时称为“ GCC Explorer”，因为它已受其支持）发展成为一个非常重要的资源，可用于学习有关编译器，优化和教授C ++和其他语言的知识。





# Compiler Explorer
PPT: https://github.com/CppCon/CppCon2019

https://www.bilibili.com/video/BV1pJ411w7kh?p=93









Compiler Explorer 已经这么牛逼了…… - 空明流转的文章 - 知乎
https://zhuanlan.zhihu.com/p/127851513

一直以来Compiler Explorer都是（我知道的）最好的C++ Sample Code的在线编译网站。

我大概从2013/14年左右开始用它来实现一些原型、测试跨编译器的兼容性、测试编译器bug，还有分析生成的汇编，等等。最近看CppCon 2019发现它进化的更牛逼了




现在除了可以看ASM之外，还能运行，看LLVM IR，看语法树，用LLVM-mca做静态性能分析，看代码块的图，甚至还能搞成6502汇编……

而且能选的library也多多了。



再整整说不定就成了一个cloud C++ 开发环境







# cppinsights

https://cppinsights.io/



https://cppinsights.io/about.html




C ++ Insights是基于clang的工具，可以进行源到源的转换。它的目标是使事物可见，而这些事物通常在幕后有意发生。这是关于编译器为我们做的神奇的事情。或浏览编译器的类。

前一段时间，我开始研究C ++ 11，C ++ 14，C ++ 17和C ++ 20带来的一些新功能。惊人的东西，例如lambda，基于范围的for循环和结构化绑定。我把它放在一起谈。您可以在线找到幻灯片和视频。

但是，所有这些研究以及我的一些培训和教学使我开始考虑如果可以在编译器的眼中看到，那会是怎样的情况。当然，至少对于clang，有一个AST转储。使用诸如Compiler Explorer之类的工具，我们可以看到编译器从C ++源代码片段生成的代码。但是，我们看到的是汇编程序。AST和Compiler Explorer的输出都不是我编写代码的语言，因此我最为熟悉。另外，在教学生用C ++演示AST并说明其全部内容时，这对我来说并不十分令人满意。

我开始写一个基于clang的工具，该工具可以将基于范围的for循环转换为编译器内部版本。然后，我对结构化绑定和lambda执行了相同的操作。最后，我按照最初的计划做了很多工作。它显示了在何处调用运算符，以及编译器进行强制转换的位置。C ++ Insights可以推断出auto或后面的类型decltype。目标是产生可编译的代码。但是，这并非在所有地方都可行。

尽管如此，仍有工作要做。

我并不是说所有事情都做对了。我认为这只是C ++ Insights的初始版本，足以将其发布给公众。另外，请记住，它完全基于clang以及我对C ++和AST的理解。

例如，您可以查看lambda，基于范围的for-loop或auto的转换。当然，您可以转换任何其他C ++代码段。

对于那些喜欢视频的人，Youtube上有一个C ++ Insights系列。如果您有喜欢我谈论的话题，请与我联系。

在此网站上运行的C ++ Insights版本的版本信息可在以下位置找到：https : //cppinsights.io/version。

您可以在Github上找到Web前端的源代码和工具C ++ Insights。

如果您想支持该项目，请考虑提交补丁。另一种选择是成为Patreon支持者。














# Quick C++ Benchmark
Support Quick Bench Suite

https://quick-bench.com/



什么是快速工作台？
Quick Bench是一个微型基准测试工具，旨在快速简单地比较两个或多个代码段的性能。

为什么要显示（CPU时间/ Noop时间）比率而不是实际时间？
该基准运行在负载量未知且潜在数量次于其他多个基准的AWS机器池上。它可以输出的任何持续时间都是没有意义的。在给定的时间段中，摘要需要100毫秒才能在Quick Bench中运行，这一事实并没有提供有关在给定的架构下在应用程序中运行将花费多少时间的任何信息。

但是，Quick Bench可以在相同条件下运行的两个代码片段之间进行合理的比较。这就是创建该工具的目的。删除任何单位都只能确保有意义的比较。

在空函数上使用比率还具有另一个优势：如果优化后您的基准测试的运行速度与Noop一样快，则优化程序可能会将您的代码优化了！





































