





穷举不是一个有效的方法，万法归一，数学最直观，各种剪枝法启发式算法本质还是穷举，或者是遗传算法那样的随机遍历解空间寻找解向量！！、

元认知=小学生就能懂的层面谈自己对世界规律的理解

本质的数学求解问题方法有：
# 归纳法

特殊例子------>一般定理，Roll------>拉格朗日中值定理
历史进程的原因，牛顿把看到的给了我们，于是我们轻易看到更多，但是绝对不是拿着公式就是背书，当然在现有的二级结论走更方便，但是二级结论书上记着就行，脑子记住只为考试，实际上要用的研究几遍就记住了。考试测试，其实是资源竞争的筛选手段，因为这个看着就合理，这些二级结论记住多难呀，会套公式，会套算法解决已经被别人解决过并且发展成为一个成熟的解决方法多难呀。



看到多少，决定你能往前走一步走多少。

看得越多，走的越远。

历史是不断前进的，正是因为先贤看得远，我们呢才能在他们基础之上看得更加远。而计算机技术让我们能算更多，能看更多，就应该做更多！






a good notation is more in need than new theries.有些问题，比如Johnson二工件生产排版问题会发现，很直观很形象，但是代数语言舍弃直观性来保证他的包容性可扩展性和更加地抽象难以理解，但是代数语言最最最有效！

从现有的结论可以推演出电话本那么多的结论，我学习的时候最喜欢就是拿着一只笔已知瞎推导，每每在这个“自洽”的理论中打通联系，编织网络，自然而然地推导出书上的结论的时候，都会惊为天人，把笔记放在书页一角，虽然知道这些结论只要在现有的公理下拿计算机穷举一定能出来，历史上一个角落一定也已经有无数人推演过，总会禁不住感到洗涤心灵，觉得自己不是在背公式，背解题套路，而是在跟着先烈的脚步推演出“自己理解的世界运作的规律”。
但是很多时候，我在推到的时候很容易推完一个长长的不知道有什么用的定理结论，脑子放空空，结论记在书上然后丢掉，整个人进入贤者时间，公式推导完成了，脑力体操手写训练之后，想“我刚刚推到这个结论有什么用？”
所以有了下面这个问题：
-  面向结论的推导，面向求解问题的推导，面向猜想证明的推导才有意义。
所以我们数学题目训练我们从已知到未知结论的**证明求解技巧，奇淫怪技**。但是人脑能接受的复杂度是有限的，能记住的二级结论也是有限的，所以当已有的这些“看着还算简单的结论定理”已经多到不能够Keep in  mind.我们就会遇到复杂度瓶颈，参考机器学习的成功例子我们不难看出，其实本质就是给人脑“减负”----------------机器证明，定理证明。
通常想明白一个问题，更多的问题来了，我们怎么引导计算机证明自己的猜想是否正确？证明求解技巧计算机可没有，让计算机在已知的定理结论中“穷举”不是好办法，可能需要一些二级结论当作跳板的时候，就应该给这些重要的节点“状态”加权重，
**设计一个一个定理状态结点之间状态跳转迭代搜索目标猜想点的算法（状态自动机）**，找到计算几何中图的目的点（搜索的猜想）是否在我们研究的的二元运算+算法（群）里面，如果找到，皆大欢喜，找不到，宝宝很难受。

https://zhuanlan.zhihu.com/p/24950767
？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？

这个搜索算法怎么设计？，或者说，他存在吗？如果假设它存在能推出它不存在或者其他毛病的话，说明不存在。
但是我们明明可以通过训练动脑做会一些比较难的“奥数题目”，那些面向结论找已知条件去证明的技巧“难道就不能编程实现？”难道定理猜想证明推论只能靠一些人的脑筋急转弯？

？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？
绝望地是，我们来判断一个算法是不是可以被判断死循环的算法都写不出（这里链接图灵的死机问题的引用）


3b1b马同学《神奇的矩阵12》《复分析可视化》等等致力于的数学语言翻译成：定理建模抽象之前的原本问题的直观体现，自然语言，图像语言等等直观的原因，其实也是因为人力有时穷，人总是喜欢自己能够“理解的”。其实这些可视化在简单的公式还算直观，比如线性代数矩阵相乘，向量转动，投影，行列式算面积还算直观，但是他们递归出来的“广义计算符号表达式”在它们分别对应的语法分析器看来，也会很难的，也会一点都不直观，所以大牛们选用代数语言，原因仅仅是因为他们“算起来简单，能被猴子的小脑袋“理解！””

再举个例子：复变函数最最最基本的代数运算本质都能写成极坐标向量的可视化，乘除加减共轭积分微分累积损失变化率等等，但是为什么高级一点的还是用代数语言去推导？如果没有计算机数学作图软件，你有空去圆规直尺画半天吧。代数语言的简洁注定高效，是解决同样问题的“二律背反”呸，不是，**是解决同样问题各种同构的算法理论体系结构中“计算复杂度最小的”**，因为复数域研究信号处理，去除噪音方便，所以我们用拉普拉斯变换，傅里叶变换来作为研究用的建模语言，测量到的时域信号（坐标变换）得到的一个假象坐标系，坐标轴等信息发现居然研究起来那么简单方便，然后得到的想要的结论在坐标变换回来。------------坐标住转换可以参考欧拉公式笛卡尔和极坐标，线性代数的变换矩阵，态，四元数，黑塞矩阵隐函数参数方程，同族积分变换三角变换...，傅里叶变换拉普拉斯变换机械工程测试技术里的各种变换，卷积概率论的t=x-1，换元法，x2=a*x1-b像3b1b的坐标变换可视化等等。

奥卡姆剃刀定律（Occam's Razor, Ockham's Razor）“如无必要，勿增实体”。既然什么方法建模描述这个问题求解都是同构的，那当然是什么方法简单用什么方法 ！正如解决合适问题用合适方法：计算矩阵问题的时候用matlab，机器学习用matlab，网站用java js等等特定合适的地方用对应的“约定方法”......而且人类的本质就是复读机，只要有“知识轮子”来用的话，谁还想做新的推导呢？当然是科研过程中当一个“Ctrl+CV程序员啦”。那不叫抄袭，叫代码复用；那叫学术引用...呃。。。。。。生态真的很重要，人类就应该团结起来做研究，当然，资源分配还是要靠竞争的，而且寄生虫还是有的，但是付出多少就意味着收获多少。


为了变换到一个方便研究，最方便分类研究这个问题的自然规律找到各种“同构数学模型”中最最最最简单的，可以发现线性代数采用的是求秩，相似对角化，利用运算封闭性化简到最最本质的分类方式。BIBD中也是这样，行列可换，但是找到最简单的满足的约束条件br=vk&&r(k-1)=lambda*(v-1)，然后x-y=p-q求解发现只有差分集能满足，接着问题简化成在“差分集这个一直规律发现的更加简单的规律定理“进行运算，可以编程实现复杂度不会太高的计算结果！

- 以前，我以为“约束条件br=vk&&r(k-1)=lambda*(v-1)”存在这样的最本质的推导，但是我后来想明白了，他们随便那两个都是可以张成“原空间”的独立无关向量组，我们只是找到最简单的分类方式来研究他们罢了。



而图灵TM机，里奇lambda表达也是只是一种不一样的建模方式，还是那句话：人啊，还是什么方法简单就用什么方法（剃须刀）Haskell的代码真是短得要命！秒！类型系统，没有变量，柯里化函数一个一个带入参数，monad 高阶函数，惰性求值等等，太妙不可言了！Haskell最美的地方感觉是他的代码和数学公式之间翻译的直观对应，能被写成数学公式来推导！（机器证明现在也有的问题就是计算机语言和数学语言，自然语言不一样，证明过程是一本电话本，凭谁都读不懂，Haskell不会，他的推演很严格逻辑意味着我们数学公式可以模拟推导过程，当然会像代数过程，我们会丢失一部分直观感受------coq语言定理证明也是这样醉醉的）

Haskell中的替换循环的递归实现的λ不动点函数的设计更是妙不可言！
**这里参考（不动点知乎回答函数的不动点和矩阵特征值有什么联系？ - Tridu的回答 - 知乎
https://www.zhihu.com/question/263431508/answer/574084280）**，我感觉这个和“不变量理论有关”，任何一个同构的         
| 输入| @   | 系统|  =   | 输出| 必然可以移项得到| 输入| @   | 系统|  -j   | 输出| =0这个约束等式，求解就会发现系统一定是有不变量的，看不同《不变量理论》的书就能找到，例子的话，看   物理过程中狭义相对论推导中出现那个i和洛伦兹变换不变量，看邱维声《高等代数》下的用不变量最简的矩阵对问题进行分类解决二次方程椭圆形双曲方程的分类，各种群论中的不变量，矩阵特征根，求导算子求导运算的特征根是e^x(由此产生的一阶二阶系统的一顿控制论公式血案)




问题在复杂度能接受的算法可解=问题解决了!
根据能否在多项式时间复杂度内求解的算法解决这个问题，可以分成P,NP，NP难问题等等。



PS:上一段的思路有点像：递归采用系统栈保存上次求出来的值，迭代循坏采用一个用户设计的循环变量或者数组来实现保存上一次求解到的值的功能。他们是同构的，而且一些时候会发现，递归定义就像穷举一样，很好想，指数增长，像斐波那契一样是自然增长的复利计算规律，包含三大常数**（这里可连接参考我之前关于这个的链接回答）**斐波那契数列为什么那么重要，所有关于数学的书几乎都会提到？ - Tridu的回答 - 知乎
https://www.zhihu.com/question/28062458/answer/674150673















人力有时穷，计算机机器演算，用Haskell编写高数，微积分，拓扑流形，集合，线性代数，群论，复分析复几何，......数学方言的互相转换过程=======也就是编译原理的高级语言转换！！！！和编程语言一样，他们都能描述解决实际问题，但是和数学语言一样，他们都有自己擅长的领域部分，不应该把他们混为一谈，但是可以各种可视化打通他们之间的联系。

所谓定理，说白了只是人的小脑袋记不住那么多衍生的结论公式，当现有理论推导出**比较好看的结论或者比较神奇有用的定律**的时候，会对此感到惊讶，不知道为什么而去证明的“好奇心”。

猜想假说，更多是在各种计算过程中猜想得到的定律。






每种语言的本质都是：数据结构（描述问题建模的集合元素+元素之间的特定实际问题建模而来的运算，也就是说群：在数学中，群表示一个拥有满足封闭性、结合律、有单位元、有逆元的二元运算的代数结构，包括阿贝尔群、同态和共轭类）+算法（穷举最好想，但是指数增长，组合问题更是如此，着）











# 观察约束条件，
求解问题满足的基本规律定理，求解方程，在有限的时间资源求解。
基本规律=公理------>运算封闭性BIBD------>推演


复变老师说过：穷举不是一个好办法。邓老师也说，一般这样会把问题求解的难度变成指数增长。




# 


# 










































































































































































































































































































































































































