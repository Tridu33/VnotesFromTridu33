

# Program Transformation












程序转换
该页面的目的是大致概述什么是程序转换，并提供有关DMS Software Reengineering Toolkit如何 使其可用于自定义工具的想法 。

基础知识：程序转换（动词）是将一个程序转换为另一个程序的过程。该过程是使用一组单独的程序转换（名词）来实现的，这些程序转换是将一个正式系统（编程语言是一种特殊情况）中的子结构映射到另一个（可能是相同的）正式系统的知识点。

下面是一个（源到源）程序转换的非常简单的示例（与实际DMS相比略有简化）：

          转换additive_identity：\ X + 0-> \ X

含义变换（结构我们称之为一个），其具有指定的任意子表达的表达 \ X ，一个附加操作，和常数为零，入刚刚的子式 \ X 以相同的语言。使用名称additive_identity，以便人们可以在较大的集合中命名各个转换。

如果additive_identity两次应用于以下源代码表达式：

          （（Q * 7 + 0）* Z + 0）/（S + 0）
将产生以下结果：

          （（Q * 7）* Z）/（S + 0）
真正的工具：通常会有某种 转换引擎（例如DMS） 来解释知识点，以对子结构执行其指令。程序转换系统是一组包括这种引擎的工具。

效用：显然，如果只有一个简单的程序转换（例如我们的示例），则只能做一些琐碎的事情，就像九年级学生学习他的第一个代数规则一样。但是，就像具有大量代数知识的数学家可以进行出色的数学推理一样，转换集也可以用于各种软件工程任务，包括优化代码，翻译计算机语言（请参阅B-2 Stealth Bomber软件迁移，例如），进行符号推理，进行大量源代码更改，代码生成等。虽然通常认为这是独特且孤立的技术，但在 编织 和重构方面 实际上只是程序转换的特殊情况，因此可以使用程序转换系统直接实现。

语言，结构和含义：通常，正式的符号体系是一种语言。所有语言都具有某种结构，并且该语言的含义或“语义”通常可以由语言结构的含义组成。程序转换通常是保留[优化，翻译，细化，重构...]的语义-（或“正确性-”），但可用于更改“程序”（语言实例）的语义[将参数添加到一个过程，将所有数组范围调整一个，删除与函数相关的所有代码，...]。

应用条件：大多数单个程序转换不能在似乎适用的所有可能情况下使用（例如，它们可能违反正确性），因此许多转换都具有应用条件，必须在应用条件之前对其进行检查。C语言的（源到源）转换示例：

          转换autoinc：
               如果NoSideEffects（\ X），则
               \ X = \ X +1-> \ X ++

此转换的应用条件是，相同的精确表达式\ X出现在等号的两侧，并且\ X表示的表达式没有任何副作用，并且不调用任何具有副作用的过程。（关于如何指定和实现应用程序条件，存在完全不同的讨论。）如果满足了应用程序条件，这将改变

          P [Q（N，7）] = P [Q（N，7）] + 1
至

          P [Q（N，7）] ++

大多数实际编程语言的应用程序条件都需要进行 流分析， 以了解如何在程序元素之间传递信息。作为示例，将使用这种流分析来支持通过分析其调用的过程确定\ X没有副作用。











结构化处理：实用的程序转换系统必须以要转换的语言（而不是简单的文本字符串）读取语言，而是根据语言的结构，然后直接在该结构上进行程序转换。基于字符串的语言的结构通常由抽象语法树表示。典型编程语言（例如Y = X + 1）中的表达式片段的语法树的图形通常为


            = 
           / \ 
          Y + 
             / \ 
            X 1

诸如DMS之类的实用系统在内部将这些语言表示为类似于字符串的语言的“抽象语法”树，或者更普遍地表示为允许它们也处理图形语言的图形。

可靠性：这种对结构的关注使程序转换比进行字符串修改（以PERL或SED为例）成为一种进行精确更改的可靠机制，因为程序转换是用语言的自然结构表示的。这意味着用程序转换系统在语法上犯愚蠢的错误要困难得多，例如仅仅因为从文本上看正确就转换了注释的内容。字符串黑客工具通常具有吸引力，因为它们易于获取和易于理解，并且通常会成为更改源程序的糟糕工具。

正确性检查：现在，可以在保留语义方面犯错误（想象一下，将if条件置于上面的自动增量转换之外）。程序转换本身在这方面是中立的。他们只是简单地将结构改变为结构。验证程序转换是否意味着保留不是程序转换系统通常要做的。它可能有辅助支持来帮助您解决此问题。但是，用语言结构表示程序转换比验证字符串对字符串的hacks容易得多。

从源到源的转换允许使用源语言和目标语言的语法来编写所需更改的表达。请参阅autoinc示例。由于这使语言结构更明确，因此它们往往更容易编写和验证。大多数源到源转换系统将单个程序转换表示为参数化语言片段对（称为箭头），称为模式，其中参数代表占位符（例如\ X可能会与其他适当的语言片段相匹配。替换左侧的匹配项后，箭头左侧的模式用于匹配，右侧的模式用于替换。类基础语言和具有下推式堆栈的汇编语言之间的源到源转换映射的示例：

          transform map_for_stmt_to_assembly:
                for \v=\i to \u step \s do \b
                 ->
                     \i
                top: STORE \v
                     \b
                     PUSH \v
                     ADD  \s
                     DUP
                     CMP  \u
                     JLE top
Procedural program transformations are bits of procedural code (written in conventional languages such as C++ or LISP) that navigate around the structures (e.g., crawling over the tree graph) by explicitly specifying checks for node types and transitions across arcs, and specify individual changes to node types and arcs. A procedural transformation for the auto-increment might be coded as


   procedure autoinc(t: tree)
      begin
        if IsEqualNode(root(t).nodetype)
           and IsPlusNode(rightchild(root(t)))
           and IsNumberNode(rightchild(rightchild(root(t))))
           and NumberValue(rightchild(rightchild(root(t))))==1
           and EqualTrees(leftchild(root(t)),leftchild(rightchild(root(t))))
           and NoSideEffects(leftchild(root(t)))
        then
           nodetype(root(t))=AutoIncNode;
           delete(rightchild(root(t));
        endif
      end

It should be clear that this procedural transform will simply ignore the Y = X + 1 tree above. It should also be clear that one has to write a lot more code to express the same transformation as a procedure, and that it is a lot less readable.







应该清楚的是，该过程变换将仅忽略上面的Y = X + 1树。还应该清楚的是，人们必须编写更多的代码来表示与过程相同的转换，并且可读性差得多。

有许多实现这种过程转换的系统，包括传统的编译器（在将高级语言转换为低级汇编语言方面非常成功）。这些系统之所以通用，是因为一旦将语言结构以一种编程语言实现在数据结构中，便开始以该编程语言进行编码以导航/修改这些数据结构是微不足道的。结果，许多特定于语言的程序转换系统（例如OpenC ++）都以这种方式实现。好消息是，这些技术已广为人知和广泛使用。新术语**CodeDom**最近，似乎开始描述代表类似编译器的“抽象语法树”（编译器社区已经非常好称呼）并允许人们对其进行程序爬网的软件工具。坏消息是，以这种方式编写转换仍然很痛苦，因为转换工程师必须了解结构表示形式的每个微小细节，并使它们正确无误。（我们注意到许多代码域并不能真正代表足够的细节来完成此操作，例如，MS Visual Studio 2008中的C＃CodeDom并未提供有关表达式结构的任何细节。）

由于需要从模式中隐式提取结构，执行结构匹配，应用程序条件检查和更新结构，因此实现源到源转换系统比实现过程转换系统要困难得多。与使用纯过程转换系统相比， 使用源到源转换系统要容易得多。我们期望对autoinc的过程转换之间进行比较 源到源版本使这一点显而易见。验证过程转换以保留语义也很痛苦，因为它们在结构的微过程动作中表达。DMS提供了一个程序程序转换接口，但是通常很少使用。

转换集：因为源到源转换模式是有限的，所以它们匹配的结构通常是有限的，替换片段也是如此。这意味着单个源到源程序的转换可以与基础图结构上的有限“半径”相匹配并最多替代。因此，无法通过单个源到源程序转换来进行任意大的更改。通常，许多程序转换被组合在一起，以协同实现更大的效果。可以将这样的集合视为代表更复杂的变换，该变换具






