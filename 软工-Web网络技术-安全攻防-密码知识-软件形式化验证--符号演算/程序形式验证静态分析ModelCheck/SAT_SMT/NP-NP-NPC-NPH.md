# 1. NPC
P 问题（Polynomial Problem），已找到多项式时间的快速算法**求解**的问题构成的集合
P：算起来很快的问题,
P类的定义 确定性 Turing Machine（简单来说其实就是定义了一个算法）在**多项式时间内可解决**的判定问题。

NP 问题（Non-Polynomial ），NP 问题是可在多项式时间内**验证**已确定答案的问题。；
问题的解可在多项式时间内得以验证（checked）的问题构成的集合.
NP：算起来不一定快，但对于任何答案我们都可以快速的验证这个答案对不对

NP-hard：比所有的NP问题都难的问题。任意一个NP的问题都可以多项式**规约**到它。

NP-complete：满足两点：
1. 是NP hard的问题（任意一个NP的问题都可以多项式**规约**到它）
2. 是NP问题（多项式时间**验证**）




https://segmentfault.com/a/1190000039915527

![1460000039915529](_v_images/20210512120338761_6308.png)








怎么理解 P 问题和 NP 问题？ - 葆芙露莎的回答 - 知乎
https://www.zhihu.com/question/27039635/answer/408025594





是否 NP类问题=P类问题？

即，是否所有能在多项式时间内验证得出正确解的问题，都是具有多项式时间算法的问题呢？

NP完备


https://zh.wikipedia.org/wiki/NP%E5%AE%8C%E5%85%A8





所有 P 问题都包含于 NP 问题的集合

证明一个问题能在多项式时间内完成比较容易，但不能解是十分困难的。就像经常谈论的 UFO，要证明它的存在，只需获取一架 UFO 即可，但要证明它的不存在，最笨的方法自然是遍历整个宇宙空间。

比如子集和（subset sum）的问题，目前尚未发现解出子集和的多项式时间算法，但也不能证明这种算法就不存在。

怎么理解 P 问题和 NP 问题？ - uraj的回答 - 知乎
https://www.zhihu.com/question/27039635/answer/35040172
普林斯顿的书，computational complexity: a modern approach

计算复杂度理论使用规约（reduction）方法比较两个问题的难度。约简是把一个问题转换成另一个问题进行解答的方法。假如有一个约简算法能把 B 的输入值适当地变换成 A 的输入值，那么利用解 A 题的最快算法和约简算法就能编写解 B 更难的问题。



NPH问题。

称问题L是NP-hard，如果任意一个NP的问题都可以多项式规约到L。


如果一个NP-hard的问题L本身就是NP的，则称L是NP-complete。这个定义可以推广到所有复杂度类。所以compleness的直观解释就是，我能解决这个问题就相当于具备了用相同级别的计算资源解决这个复杂度类里所有问题的能力。



NP问题并不是那种“只有搜才行”的问题，NPC问题才是。

NP-Hard问题是这样一种问题，它满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比 NPC问题的范围广）。NP-Hard问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是NP问题。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。事实上，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高从而更难以解决。


事实上，的确所有的NP问题都可以规约到某一些NP问题，这类问题也就是经常出现的NP complete问题，比如TSP（旅行商）问题。


一般情况下非判定问题都可以转化为多项式时间次数的判定问题，所以P和NP的计算复杂度概念可以适用于几乎所有算法问题。



现在可以知道，由于所有的NP问题都可以多项式规约到某一个NP Complete问题，所以只要一个NP Complete问题能在多项式时间内得到解决，那么所有的NP问题都可以在多项式时间内得到结局了。


逻辑电路问题。这是第一个NPC问题。其它的NPC问题都是由这个问题约化而来的。因此，逻辑电路问题是NPC类问题的“鼻祖”。
逻辑电路问题是指的这样一个问题：给定一个逻辑电路，问是否存在一种输入使输出为True。

逻辑电路问题属于NPC问题。这是有严格证明的。它显然属于NP问题，并且可以直接证明所有的NP问题都可以约化到它（不要以为NP问题有无穷多个将给证明造成不可逾越的困难）。证明过程相当复杂，其大概意思是说任意一个NP问题的输入和输出都可以转换成逻辑电路的输入和输出（想想计算机内部也不过是一些 0和1的运算），因此对于一个NP问题来说，问题转化为了求出满足结果为True的一个输入（即一个可行解）。


> SAT问题（第一个NPC问题）。该问题的基本意思是，给定一系列布尔变量以及它的约束集，是否存在一个解使得它的输出为真。
> minisat到**SMT solver z3**等牛逼之处在于，这是通用的求解底层工具,只需要做好前段reduction工具，几乎任何算法任务都可以复用SOA 的smt solver求解，问题就是smt solver的计算瓶颈。

有了第一个NPC问题后，一大堆NPC问题就出现了，因为再证明一个新的NPC问题只需要将一个已知的NPC问题约化到它就行了。后来，Hamilton 回路成了NPC问题，TSP问题也成了NPC问题。现在被证明是NPC问题的有很多，任何一个找到了多项式算法的话所有的NP问题都可以完美解决了。因此说，正是因为NPC问题的存在，P=NP变得难以置信。


目前常见的计算机问题几乎都是NP的（多项式时间内能验证结果，大部分算法问题都满足），也就是说，如果能多项式时间解决某一个NP Complete问题(p == NP)的话，几乎所有的算法问题都能在多项式解决了。，

会不会所有的问题都可以找到复杂度为多项式级的算法呢？很遗憾，答案是否定的。有些问题甚至根本不可能找到一个正确的算法来，这称之为“不可解问题”(Undecidable Decision Problem)。

























