





# 《领域特定语言》Domain-Specific Languages

https://tomassetti.me/domain-specific-languages/ 入门链接简短介绍


https://martinfowler.com/dsl.html 作者博客


https://refactoring.com/catalog/


https://martinfowler.com/dslCatalog/ 目录

# DomainSpecificLanbuage领域专用语言DSL

前端 DSL 实践指南（上）—— 内部 DSL - 郑海波的文章 - 知乎
https://zhuanlan.zhihu.com/p/107947462







[Wikipedia](https://en.wikipedia.org/wiki/Domain-specific_language) 对于 DSL 的定义还是比较简单的：

A specialized computer language designed for a specific task.

为了解决某一类任务而专门设计的计算机语言。
与 DSL 相对的就是 GPL General Purpose Language 的简称，即通用编程语言，也就是我们非常熟悉的 Objective-C、Java、Python 以及 C 语言等等。

另一个世界级软件开发大师 Martin Fowler 对于领域特定语言的定义在笔者看来就更加具体了，DSL 通过在表达能力上做的妥协换取在某一领域内的高效。

而有限的表达能力就成为了 GPL 和 DSL 之间的一条界限
最常见的 DSL 包括 Regex 以及 HTML & CSS，在这里会对这几个例子进行简单介绍




总结下来，实现 DSL 总共有这么两个需要完成的工作：

- 设计语法和语义，定义 DSL 中的元素是什么样的，元素代表什么意思
- 实现 parser，对 DSL 解析，最终通过解释器来执行

在上一节讲到的 DSL 其实可以被称为外部 DSL；而这里即将谈到的嵌入式 DSL 也有一个别名，内部 DSL。

这两者最大的区别就是，内部 DSL 的实现往往是嵌入一些编程语言的，比如 iOS 的依赖管理组件 CocoaPods 和 Android 的主流编译工具 Gradle，前者的实现是基于 Ruby 语言的一些特性，而后者基于 Groovy。

CocoaPods 以及其它的嵌入式 DSL 使用了宿主语言（host language）的抽象能力，并且省去了实现复杂语法分析器（Parser）的过程，并不需要重新实现模块、变量等特性。

嵌入式 DSL 的产生其实模糊了框架和 DSL 的边界，不过这两者看起来也没有什么比较明显的区别；不过，DSL 一般会使用宿主语言的特性进行创造，在设计 DSL 时，也不会考虑宿主语言中有哪些 API 以及方法，而框架一般都是对语言中的 API 进行组合和再包装。

我们没有必要争论哪些是框架，哪些是 DSL，因为这些争论并没有什么意义。



最出名也最成功的嵌入式 DSL 应该就是 Ruby on Rails 了，虽然对于 Rails 是否是 DSL 有争议，不过 Rails 为 Web 应用的创建提供大量的内置的支撑，使我们在开发 Web 应用时变得非常容易。



Linux 系统下有很多配置文件，每个配置文件格式都不大一样，它们可以被看成是多种 DSL。IP Tables 的规则是一种 DSL，FVWM 窗口管理器的配置文件是一种 DSL，VIM 和 Emacs 的配置文件，当然也是 DSL。Makefile 是 DSL。CSS 是 DSL。JSON 是 DSL。SQL 也可以被看成是数据库领域的 DSL。也有很多人在自己的工作中创造 DSL，用它们来解决一些实际问题。



[DSL 的误区](https://www.yinwang.org/blog-cn/2017/05/25/dsl)









 《领域特定语言》


Kunle Olukotun在Stanford开设的课程CS 442: High Productivity and Performance with Domain Specific Languages in Scala, 2011, Online http://web.stanford.edu/class/cs442/ 。 但这门课是研究性质的，即主要以Stanford Pervasive Parallelism Lab  http://ppl.stanford.edu/  (PPL)组开发的Delite作为基石讲解。 因而在这里我只会将部分通用的重要的章节抽取出来。


chhzh123.github.io/blogs/2019-02-12-dsl/#简介






常见的DSL如

图像处理OpenGL
科学计算Matlab
排版软件TeX
数据库MySQL
DSL的好处

提高生产力
将程序员从复杂的并行编程中隔离开来
注重于算法应用实现而不是底层细节
提高性能
更加符合一般化的并行执行领域高层抽象
限制表达力(expressiveness)进而更易提取可用并行
用领域知识做静态/动态优化
可移植性(portability)与前向可扩展性(forward scalability)
DSL和Runtime能够进化到利用最新硬件特性的优势
应用无需改变
允许革新硬件而不用担心应用的可移植性
两种DSL
一种依赖于宿主语言(embeded DSL, “Just a library”)
方便开发，可以重用整个宿主语言
方便学习，只需有宿主语言的基础
能够结合多种DSL在一个程序中
能够共用DSL基础设施
但难以通过领域知识优化
与宿主语言一样面向同一硬件
例子
Halide依赖于C++编译到汇编/cuda
Chisel依赖于Scala编译到Verilog
一种做更高层的抽象(stand-alone)
能够做大量优化
但需要大量人力来实现一门充分成熟的语言
全套的编译器/优化
工具链(IDE、调试器)
多种DSL之间的交互比较麻烦（这倒不是太大问题）
例子
GraphIt直接编译为C++
Spatial直接编译为Chisel
需要做得更好，目标是设计一门嵌入式的DSL，但是性能和单一的DSL一样

典型的编译器

DSL采用高度可表达的嵌入式语言的前端(Scala)
但可以定制化IR和后端Pass(Delite)




语言(language)与框架(framework)的区别
编程语言主要是一系列的语法语义规则
框架 https://chhzh123.github.io/blogs/2019-01-31-deep-learning-and-graph-analytics-frameworks/ 则是用现成的编程语言写成的一些库(library)/工具(tool)的集合，提供API接口，重用性高(reusable)，避免重复造轮子，可以直接调用















# 领域特定语言


```


目录  · · · · · ·
译者序
前言
第一部分　叙　　述
第1章入门例子2
1.1　哥特式建筑安全系统2
1.2　状态机模型4
1.3　为格兰特小姐的控制器编写程序7
1.4　语言和语义模型13
1.5使用代码生成15
1.6　使用语言工作台17
1.7　可视化20
第2章　使用DSL21
2.1定义DSL21
2.1.1DSL的边界22
2.1.2片段DSL和独立DSL25
2.2为何需要DSL25
2.2.1　提高开发效率26
2.2.2与领域专家的沟通26
2.2.3执行环境的改变27
2.2.4其他计算模型28
2.3DSL的问题28
2.3.1语言噪音29
2.3.2构建成本29
2.3.3集中营语言30
2.3.4 “一叶障目”的抽象30
2.4广义的语言处理31
2.5DSL的生命周期31
2.6设计优良的DSL从何而来32
第3章实现DSL34
3.1DSL处理之架构34
3.2解析器的工作方式37
3.3文法、语法和语义39
3.4解析中的数据39
3.5宏41
3.6测试DSL42
3.6.1语义模型的测试42
3.6.2解析器的测试45
3.6.3脚本的测试49
3.7错误处理50
3.8DSL迁移51
第4章实现内部DSL54
4.1连贯API与命令–查询API54
4.2解析层的需求57
4.3使用函数58
4.4字面量集合61
4.5基于文法选择内部元素63
4.6闭包64
4.7解析树操作66
4.8标注67
4.9为字面量提供扩展69
4.10消除语法噪音69
4.11动态接收69
4.12提供类型检查70
第5章实现外部DSL72
5.1语法分析策略72
5.2输出生成策略74
5.3解析中的概念76
5.3.1单独的词法分析76
5.3.2文法和语言77
5.3.3正则文法、上下文无关文法和上下文相关文法77
5.3.4自顶向下解析和自底向上解析79
5.4混入另一种语言81
5.5XML DSL82
第6章内部DSL vs 外部DSL84
6.1学习曲线84
6.2创建成本85
6.3程序员的熟悉度85
6.4与领域专家沟通86
6.5与宿主语言混合86
6.6强边界87
6.7运行时配置87
6.8趋于平庸88
6.9组合多种DSL88
6.10总结89
第7章其他计算模型概述90
7.1几种计算模型92
7.1.1决策表92
7.1.2产生式规则系统93
7.1.3状态机94
7.1.4依赖网络95
7.1.5选择模型95
第8章代码生成96
8.1选择生成什么96
8.2如何生成99
8.3混合生成代码和手写代码100
8.4生成可读的代码101
8.5解析之前的代码生成101
8.6延伸阅读101
第9章语言工作台102
9.1语言工作台之要素102
9.2模式定义语言和元模型103
9.3源码编辑和投射编辑107
9.4说明性编程109
9.5工具之旅110
9.6语言工作台和CASE工具112
9.7我们该使用语言工作台吗112
第二部分　通 用 主 题
第10章各种DSL116
10.1Graphviz116
10.2JMock117
10.3CSS118
10.4HQL119
10.5XAML120
10.6FIT122
10.7Make等123
第11章语义模型125
11.1工作原理125
11.2使用场景127
11.3入门例子（Java）128
第12章符号表129
12.1工作原理129
12.2使用场景131
12.3参考文献131
12.4以外部DSL实现的依赖网络（Java和ANTLR）131
12.5在一个内部DSL中使用符号键（Ruby）133
12.6用枚举作为静态类型符号（Java）134
第13章语境变量137
13.1工作原理137
13.2使用场景137
13.3读取INI文件（C#）138
第14章构造型生成器141
14.1工作原理141
14.2使用场景142
14.3构建简单的航班信息（C#）142
第15章宏144
15.1工作原理144
15.1.1文本宏145
15.1.2语法宏148
15.2使用场景151
第16章通知153
16.1工作原理153
16.2使用场景154
16.3一个非常简单的通知（C#）154
16.4解析中的通知（Java）155
第三部分　外部DSL主题
第17章分隔符指导翻译160
17.1工作原理160
17.2使用场景162
17.3常客记分（C#）163
17.3.1　语义模型163
17.3.2解析器165
17.4使用格兰特小姐的控制器解析非自治语句(Java)168
第18章语法指导翻译175
18.1工作原理175
18.1.1词法分析器176
18.1.2语法分析器179
18.1.3产生输出181
18.1.4语义预测181
18.2使用场景182
18.3参考文献182
第19章BNF183
19.1工作原理183
19.1.1多重性符号（Kleene运算符）184
19.1.2其他一些有用的运算符186
19.1.3解析表达式文法186
19.1.4将EBNF转换为基础BNF187
19.1.5行为代码189
19.2使用场景191
第20章基于正则表达式表的词法分析器192
20.1工作原理192
20.2使用场景193
20.3格兰特小姐控制器的词法处理（Java）194
第21章递归下降法语法解析器197
21.1工作原理197
21.2使用场景200
21.3参考文献200
21.4递归下降和格兰特小姐的控制器（Java）201
第22章解析器组合子205
22.1工作原理206
22.1.1处理动作208
22.1.2函数式风格的组合子209
22.2使用场景209
22.3解析器组合子和格兰特小姐的控制器（Java）210
第23章解析器生成器217
23.1工作原理217
23.2使用场景219
23.3Hello World（Java和ANTLR）219
23.3.1编写基本的文法220
23.3.2构建语法分析器221
23.3.3为文法添加代码动作223
23.3.4使用代沟225
第24章树的构建227
24.1工作原理227
24.2使用场景229
24.3使用ANTLR的树构建语法（Java和ANTLR）230
24.3.1标记解释230
24.3.2解析231
24.3.3组装语义模型233
24.4使用代码动作进行树的构建（Java和ANTLR）236
第25章嵌入式语法翻译242
25.1工作原理242
25.2使用场景243
25.3格兰特小姐的控制器（Java和ANTLR）243
第26章内嵌解释器247
26.1工作原理247
26.2使用场景247
26.3计算器（ANTLR和Java）247
第27章外加代码250
27.1工作原理250
27.2使用场景251
27.3嵌入动态代码（ANTLR、Java和JavaScript）252
27.3.1语义模型252
27.3.2语法分析器254
第28章可变分词方式258
28.1工作原理258
28.1.1字符引用259
28.1.2词法状态261
28.1.3修改标记类型262
28.1.4忽略标记类型263
28.2使用场景264
第29章嵌套的运算符表达式265
29.1工作原理265
29.1.1使用自底向上的语法分析器265
29.1.2自顶向下的语法分析器266
29.2使用场景268
第30章以换行符作为分隔符269
30.1工作原理269
30.2使用场景271
第31章外部DSL拾遗272
31.1语法缩进272
31.2模块化文法274
第四部分　内部DSL主题
第32章表达式生成器276
32.1工作原理276
32.2使用场景277
32.3具有和没有生成器的连贯日历（Java）278
32.4对于日历使用多个生成器（Java）280
第33章函数序列282
33.1工作原理282
33.2使用场景283
33.3简单的计算机配置（Java）283
第34章嵌套函数286
34.1工作原理286
34.2使用场景287
34.3简单计算机配置范例（Java）288
34.4用标记处理多个不同的参数（C#）289
34.5针对IDE支持使用子类型标记（Java）291
34.6使用对象初始化器（C#）292
34.7周期性事件（C#）293
34.7.1语义模型294
34.7.2DSL296
第35章方法级联299
35.1工作原理299
35.1.1生成器还是值300
35.1.2收尾问题301
35.1.3分层结构301
35.1.4渐进式接口302
35.2使用场景303
35.3简单的计算机配置范例（Java）303
35.4带有属性的方法级联（C#）306
35.5渐进式接口（C#）307
第36章对象范围309
36.1工作原理309
36.2使用场景310
36.3安全代码（C#）310
36.3.1　语义模型311
36.3.2DSL313
36.4使用实例求值（Ruby）315
36.5使用实例初始化器（Java）317
第37章闭包319
37.1工作原理319
37.2使用场景323
第38章嵌套闭包324
38.1工作原理324
38.2使用场景325
38.3用嵌套闭包来包装函数序列（Ruby）326
38.4简单的C#示例（C#）327
38.5使用方法级联（Ruby）328
38.6带显式闭包参数的函数序列（Ruby）330
38.7采用实例级求值（Ruby）332
第39章列表的字面构造335
39.1工作原理335
39.2使用场景335
第40章Literal Map336
40.1工作原理336
40.2使用场景336
40.3使用List和Map表达计算机的配置信息（Ruby）337
40.4演化为Greenspun式（Ruby）338
第41章动态接收342
41.1工作原理342
41.2使用场景343
41.3积分——使用方法名解析（Ruby）344
41.3.1模型345
41.3.2生成器347
41.4积分——使用方法级联（Ruby）348
41.4.1模型349
41.4.2生成器349
41.5去掉安全仪表盘控制器中的引用（JRuby）351
第42章标注357
42.1工作原理357
42.1.1定义标注358
42.1.2处理标注359
42.2使用场景360
42.3用于运行时处理的特定语法（Java）360
42.4使用类方法（Ruby）362
42.5动态代码生成（Ruby）363
第43章解析树操作365
43.1工作原理365
43.2使用场景366
43.3由C#条件生成IMAP查询（C#）367
43.3.1语义模型367
43.3.2以C#构建369
43.3.3退后一步373
第44章类符号表375
44.1　工作原理375
44.2使用场景376
44.3在静态类型中实现类符号表（Java）377
第45章文本润色383
45.1工作原理383
45.2使用场景383
45.3使用润色的折扣规则（Ruby）384
第46章为字面量提供扩展386
46.1工作原理386
46.2使用场景387
46.3食谱配料（C#）387
第五部分　其他计算模型
第47章适应性模型390
47.1工作原理390
47.1.1在适应性模型中使用命令式代码391
47.1.2工具393
47.2使用场景394
第48章决策表395
48.1工作原理395
48.2使用场景396
48.3为一个订单计算费用（C#）396
48.3.1模型397
48.3.2解析器400
第49章依赖网络403
49.1工作原理403
49.2使用场景405
49.3分析饮料（C#）405
49.3.1语义模型406
49.3.2解析器407
第50章产生式规则系统409
50.1工作原理409
50.1.1链式操作410
50.1.2矛盾推导411
50.1.3规则结构里的模式412
50.2使用场景412
50.3俱乐部会员校验（C#）412
50.3.1模型413
50.3.2解析器414
50.3.3演进DSL414
50.4适任资格的规则：扩展俱乐部成员（C#）416
50.4.1模型417
50.4.2解析器419
第51章状态机421
51.1工作原理421
51.2使用场景423
51.3安全面板控制器（Java）423
第六部分　**代 码 生 成**
第52章基于转换器的代码生成426
52.1工作原理426
52.2使用场景427
52.3安全面板控制器（Java生成的C）427
第53章模板化的生成器431
53.1工作原理431
53.2使用场景432
53.3生成带有嵌套条件的安全控制面板状态机（Velocity和Java生成的C）432
第54章嵌入助手438
54.1工作原理438
54.2使用场景439
54.3安全控制面板的状态（Java和ANTLR）439
54.4助手类应该生成HTML吗（Java和Velocity）442
第55章基于模型的代码生成444
55.1工作原理444
55.2使用场景445
55.3安全控制面板的状态机（C）445
55.4动态载入状态机（C）451
第56章无视模型的代码生成454
56.1工作原理454
56.2使用场景455
56.3使用嵌套条件的安全面板状态机（C）455
第57章代沟457
57.1工作原理457
57.2使用场景458
57.3根据数据结构生成类（Java和一些Ruby）459
参考文献463
```




















































































































